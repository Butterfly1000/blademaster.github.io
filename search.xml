<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cursor个人使用记录</title>
      <link href="/2025/07/08/Cursor%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/07/08/Cursor%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义mode"><a href="#自定义mode" class="headerlink" title="自定义mode"></a>自定义mode</h2><p>  在Agent、Ask、Manual，现在还有个Background，在这些之外，还可以自定义mode。</p><p>  我们可以设置自定义mode的一些功能：</p><ul><li>自定义命名，说明这个mode是作用于什么，例如”代码审查员”</li><li>选择可以使用的Tools，<code>Search</code>、<code>Edit</code>、<code>Run</code>(终端)、<code>MCP</code>(选择MCP工具)</li><li>还可以添加自定义介绍</li></ul><p>  **注: 使用前必须先在 设置 - Chat - Custom Modes 开启 **</p><h2 id="AI模型"><a href="#AI模型" class="headerlink" title="AI模型"></a>AI模型</h2><p>初始的AI模型可能很少，需要再 <strong>设置 - Models</strong> 开启。</p><h2 id="MCP工具"><a href="#MCP工具" class="headerlink" title="MCP工具"></a>MCP工具</h2><p>这个其他文档有详细介绍， <strong>设置 - Tools &amp; Integrations</strong>  <code>MCP Tools</code>栏 - <code>+ New MCP Server</code></p><p>MCP就是给AI权限，让AI可以去进行一些操作，举个例子fetch赋予AI自主抓取网页分析的能力，Git让AI可以查看Git分支内容。这样就可以让AI自行去分析，而不是我们获取信息再丢给AI处理。</p><h2 id="Rules规则"><a href="#Rules规则" class="headerlink" title="Rules规则"></a>Rules规则</h2><p>由于AI对于项目的一些习惯和规则是不熟悉的，需要进行设置。否则AI很可能会出现发散式思考，偏离需求。另外，AI也可能偷懒，需要通过规则让AI更准确的实现我们的需求。</p><p><strong>设置- Rules * Memories</strong> <code>Project Rules</code>栏 - <code>+ Add Rule</code> </p><h1 id="符号工具显性指定上下文"><a href="#符号工具显性指定上下文" class="headerlink" title="@符号工具显性指定上下文"></a>@符号工具显性指定上下文</h1><table><thead><tr><th>@工具</th><th>范例</th><th>使用场景</th><th>缺点</th></tr></thead><tbody><tr><td>@code</td><td>@loadAndApplyRulesTask</td><td>我们知道哪个函数、常量或符号与当下需要生成的输出相关</td><td>需要大量的代码库知识</td></tr><tr><td>@files</td><td>@check_rule.md</td><td>我们知道该读取或编辑哪个文件，但不知道文件的确切位置</td><td>可能包括许多与手头任务无关的上下文，具体取决于文件大小</td></tr><tr><td>@folders</td><td>@Invoker</td><td>文件夹中的所有内容或大多数文件都是相关的</td><td>可能包括许多与手头任务无关的上下文</td></tr><tr><td>@docs</td><td>@s3 @Amazon S3</td><td>第三方官方功能、接口等文档，也允许自定义文档，但只能远程访问</td><td>可能包括许多与手头任务无关的上下文</td></tr><tr><td>@past chats</td><td>@Chat Name Generation</td><td>应用指定历史会话</td><td>不好回溯</td></tr><tr><td>@Branch</td><td>@Branch（Diff with Main Branch)</td><td>当前分支和Main分支进行比较，用于review代码</td><td>只能和Main分支比较</td></tr></tbody></table><h2 id="多窗口处理"><a href="#多窗口处理" class="headerlink" title="多窗口处理"></a>多窗口处理</h2><p>适当开始新的聊天有助于保持专注、高效，节约成本。</p><ul><li>Ctrl+T 或是 Alt+[点击创建 chat]，可以开始新的聊天 tab 窗口，不会影响旧的聊天窗口。</li><li>如果想从当前聊天窗口中间的一个对话开个新分支问答，可以用右下角…里的 Duplicate Chat，来复制对话，开启带有上下文的聊天记录的分叉对话。</li></ul><h2 id="通过-workspaces-支持多个代码库"><a href="#通过-workspaces-支持多个代码库" class="headerlink" title="通过 workspaces 支持多个代码库"></a>通过 workspaces 支持多个代码库</h2><p>特地说明：<code>.cursor/rules are supported in all floders added</code></p><p>适合将高度相关的项目作为同一个 workspace 管理，比如比较独立高度相关的前后端项目，也可以是文档项目和代码项目，也可以是两个高度相关的服务项目等。</p><p>解决跨项目检索与同步更新问题，甚至可以不同语言项目的代码翻译。</p><p><a href="https://zhuanlan.zhihu.com/p/1909022796757042342?share_code=vcHrH8GymcLc&utm_psn=1909321731799249573">Cursor 0.5 版本发布的 Multi-Root Workspaces，才是程序员杀手应用 - 知乎</a></p><p><a href="https://mp.weixin.qq.com/s/VAxya6NUqHcvR3qehj-nGQ">绝杀！Cursor 0.50 全栈开发利器：Multi-root workspaces</a></p><p>注：存在改变团队编码协作工作方式的可能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/07/08/hello-world/"/>
      <url>/2025/07/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试新主题</title>
      <link href="/2022/11/08/%E6%B5%8B%E8%AF%95%E6%96%B0%E4%B8%BB%E9%A2%98/"/>
      <url>/2022/11/08/%E6%B5%8B%E8%AF%95%E6%96%B0%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Godoc 安装与使用</title>
      <link href="/2022/06/10/Godoc-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/10/Godoc-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简单操作："><a href="#简单操作：" class="headerlink" title="简单操作："></a>简单操作：</h2><p>首先要确保，go env的环境变量GOBIN配置正确。</p><p>使用vim打开.bash_profile文件； 打开以后，如下输入内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=/Users/douxiaobo/go</span><br><span class="line"></span><br><span class="line">export GOBIN=$GOPATH/bin</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$GOBIN</span><br></pre></td></tr></table></figure><p>然后，到项目根目录下执行<code>go get -v -u golang.org/x/tools/cmd/godoc</code></p><p>最后，执行<code> godoc -http=:6060</code>,访问浏览器<code>localhost:6060</code>,点击<strong>Packages</strong>，然后找到<strong>项目目录</strong>，点击查看。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://blog.csdn.net/sdujava2011/article/details/118926883">看这一篇就够了</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单使会用React</title>
      <link href="/2022/06/10/%E7%AE%80%E5%8D%95%E4%BD%BF%E4%BC%9A%E7%94%A8React/"/>
      <url>/2022/06/10/%E7%AE%80%E5%8D%95%E4%BD%BF%E4%BC%9A%E7%94%A8React/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Linux Centos7</p><h2 id="一、安装node-js-npm"><a href="#一、安装node-js-npm" class="headerlink" title="一、安装node.js(npm)"></a>一、安装node.js(npm)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">### yum安装npm(完成这个即可)</span><br><span class="line"></span><br><span class="line">curl --silent --location https://rpm.nodesource.com/setup_10.x | bash -</span><br><span class="line">yum install -y nodejs</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">### 常用操作</span><br><span class="line">npm init</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### node.js升级</span><br><span class="line">//安装npm升级工具</span><br><span class="line">npm install -g n</span><br><span class="line">//安装最近的稳定版本</span><br><span class="line">n stable</span><br><span class="line">---------------------------</span><br><span class="line"></span><br><span class="line">  installing : node-v16.15.0</span><br><span class="line">       mkdir : /usr/local/n/versions/node/16.15.0</span><br><span class="line">       fetch : https://nodejs.org/dist/v16.15.0/node-v16.15.0-linux-x64.tar.xz</span><br><span class="line">     copying : node/16.15.0</span><br><span class="line">   installed : v16.15.0 to /usr/local/bin/node</span><br><span class="line">      active : v10.24.1 at /bin/node</span><br><span class="line">---------------------------</span><br><span class="line">记得更换/bin/node下面的node</span><br><span class="line"></span><br><span class="line">### 升级npm</span><br><span class="line">升级到最新版本： npm i -g npm to update</span><br><span class="line">升级到指定版本： npm -g i npm@XXX </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、基础操作"><a href="#二、基础操作" class="headerlink" title="二、基础操作"></a>二、基础操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## package.json</span><br><span class="line">mkdir -p sa-frontend</span><br><span class="line">cd sa-frontend</span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line">然后就有了package.json了</span><br><span class="line"></span><br><span class="line">## 生成html</span><br><span class="line">touch index.html</span><br></pre></td></tr></table></figure><h2 id="三、安装React"><a href="#三、安装React" class="headerlink" title="三、安装React"></a>三、安装React</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g create-react-app </span><br><span class="line">$ create-react-app sa-frontend //如果提示node.js版本太低，就按照上面的升级</span><br><span class="line">-------------------</span><br><span class="line">Success! Created sa-frontend at /sa-frontend</span><br><span class="line">Inside that directory, you can run several commands:</span><br><span class="line"></span><br><span class="line">  npm start</span><br><span class="line">    Starts the development server.</span><br><span class="line"></span><br><span class="line">  npm run build</span><br><span class="line">    Bundles the app into static files for production.</span><br><span class="line"></span><br><span class="line">  npm test</span><br><span class="line">    Starts the test runner.</span><br><span class="line"></span><br><span class="line">  npm run eject</span><br><span class="line">    Removes this tool and copies build dependencies, configuration files</span><br><span class="line">    and scripts into the app directory. If you do this, you can’t go back!</span><br><span class="line"></span><br><span class="line">We suggest that you begin by typing:</span><br><span class="line"></span><br><span class="line">  cd sa-frontend</span><br><span class="line">  npm start</span><br><span class="line"></span><br><span class="line">Happy hacking!</span><br><span class="line">-------------------</span><br><span class="line">$ cd sa-frontend/</span><br><span class="line">$ npm start</span><br></pre></td></tr></table></figure><h2 id="四、html文件中引入react"><a href="#四、html文件中引入react" class="headerlink" title="四、html文件中引入react"></a>四、html文件中引入react</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- 1 引入js文件 --&gt;</span><br><span class="line">    &lt;script src=&quot;./node_modules/react/umd/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 2 创建react元素 --&gt;</span><br><span class="line">     &lt;script&gt;</span><br><span class="line">      //   param1 元素名称</span><br><span class="line">      //   param2 元素属性</span><br><span class="line">      //   param3 第三个及以后的参数 元素的子节点</span><br><span class="line">  </span><br><span class="line">      const title =  React.createElement(&#x27;h1&#x27;,null,&quot;hello React&quot;)</span><br><span class="line"></span><br><span class="line">       // 3. 渲染react元素</span><br><span class="line">       //  param1 要渲染的react元素</span><br><span class="line">       //  param2 挂载点 </span><br><span class="line">       ReactDOM.render(title,document.getElementById(&#x27;root&#x27;))</span><br><span class="line">     &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><blockquote><p>运行npm start</p></blockquote><p>访问：<code>localhost:3000</code></p><blockquote><p>如果不想用默认端口3000</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd node_modules/react-scripts/scripts</span><br><span class="line">vi start.js</span><br><span class="line"></span><br><span class="line">找到</span><br><span class="line">const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;</span><br><span class="line"></span><br><span class="line">将这边3000修改成你想要的端口9033</span><br></pre></td></tr></table></figure><p>这样就成功了，如果不成功可以查看端口是否开放。</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><blockquote><p>npm run build</p></blockquote><p>这会在项目树中生成一个名为<strong>build</strong>的文件夹。该文件夹包含了我们的ReactJS应用程序所需的所有静态文件。</p><blockquote><p><strong>用Nginx提供静态文件访问</strong></p></blockquote><p>将sa-frontend&#x2F;build文件夹的内容移到**[nginx安装目录]&#x2F;html**中。</p><p>这样，生成的index.html文件可以在[nginx安装目录]&#x2F;html&#x2F;index.html（<strong>这是Nginx的默认访问文件</strong>）中访问到。</p><p>默认情况下，Nginx服务器会监听80端口。可通过修改[nginx安装目录]&#x2F;conf&#x2F;nginx.conf文件中的server.listen参数来指定其他端口9034。</p><p>使用浏览器打开localhost:9034，ReactJS应用程序将会出现。</p><p><strong>nginx.conf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen 9034;</span><br><span class="line">     server_name  localhost;</span><br><span class="line"></span><br><span class="line">     charset &#x27;utf-8&#x27;;</span><br><span class="line"></span><br><span class="line">     root   /data/wwwroot/kubernetes/sa-frontend-item/html;</span><br><span class="line">     index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">     error_log   /data/logs/sa/error.log;</span><br><span class="line">     access_log  /data/logs/sa/access.log main;</span><br><span class="line">     location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      location ^~ /assets/ &#123;</span><br><span class="line">         gzip_static on;</span><br><span class="line">         expires max;</span><br><span class="line">         add_header Cache-Control public;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      error_page 500 502 503 504 /500.html;</span><br><span class="line">      client_max_body_size 20M;</span><br><span class="line">      keepalive_timeout 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_39008205/article/details/118551913?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165234334316782395318349%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165234334316782395318349&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-118551913-null-null.142%5Ev9%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=react&spm=1018.2226.3001.4187">React入门一：React简介及基本使用</a></p><p><a href="https://www.html.cn/qa/react/14370.html">怎么用npm安装react？</a></p><p><a href="https://blog.csdn.net/addccc/article/details/123956910">linux服务器部署react项目步骤详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger 部署(Mac)</title>
      <link href="/2022/06/10/swagger-%E9%83%A8%E7%BD%B2-Mac/"/>
      <url>/2022/06/10/swagger-%E9%83%A8%E7%BD%B2-Mac/</url>
      
        <content type="html"><![CDATA[<h2 id="编辑-swagger-edit"><a href="#编辑-swagger-edit" class="headerlink" title="编辑(swagger-edit)"></a>编辑(swagger-edit)</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>一：安装node.js</p><p>二：安装http-server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g http-server</span><br></pre></td></tr></table></figure><p>三：下载 <a href="https://github.com/swagger-api/swagger-editor">swagger-edit</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/swagger-api/swagger-editor.git</span><br></pre></td></tr></table></figure><p>四：运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd path/to/swagger-edit #就是进入到刚刚克隆的swagger-edit文件夹下</span><br><span class="line">http-servers swagger-editor</span><br></pre></td></tr></table></figure><p>五：查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认运行在8080 port</span><br><span class="line">在浏览器打开窗口 http://localhost:8080</span><br></pre></td></tr></table></figure><h2 id="显示部分-swagger-ui"><a href="#显示部分-swagger-ui" class="headerlink" title="显示部分(swagger-ui)"></a>显示部分(swagger-ui)</h2><p>一： 安装：下载 <a href="https://github.com/swagger-api/swagger-ui">swagger-ui</a></p><p>二：创建一个文件夹用于<strong>swagger项目</strong>，然后初始化到节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd path/to/swagger/project</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><p>三：</p><p>然后你可以检查这里有一个<code>package.json</code>；*(npm init后出现<code>package.json</code>很正常)*</p><p>复制dist文件(swagger-ui里面的)到<strong>swagger项目</strong>；*(就是上面的project)*</p><p>安装express模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure><p>四：</p><p>有一个node_modules文件夹和一个<code>package-lock.json</code></p><p>创建一个index.js在<strong>swagger</strong>项目下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;); </span><br><span class="line"></span><br><span class="line">var app = express();  </span><br><span class="line">app.use(&#x27;/swagger&#x27;, express.static(&#x27;dist&#x27;));</span><br><span class="line">app.get(&#x27;/&#x27;, function (req, res) &#123;  </span><br><span class="line">    res.send(&#x27;Hello World!&#x27;); </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&#x27;Example app listening on port 3000!&#x27;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>五：测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br><span class="line"></span><br><span class="line">http://127.0.0.1:3000/  #Hello World</span><br><span class="line">http://127.0.0.1:3000/swagger/ #页面</span><br></pre></td></tr></table></figure><p>自定义样式：</p><p>修改dist中的<code>index.html(新版在swagger-initializer.js里面了)</code>的url,可以指定到自定义的json<br> 默认的url: “<a href="http://petstore.swagger.io/v2/swagger.json&quot;">http://petstore.swagger.io/v2/swagger.json&quot;</a><br> 修改成 .&#x2F;swagger.json 或<code>http://localhost:8092/v2/doc</code></p><p><strong>重点：</strong></p><p>你可以下载json例子从swagger editor.</p><p>假如主机不是基于swagger url，则需要指定主机,修改<code>swagger.json</code>里面的host</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host:****:**   //swagger.json</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/jackey2015/p/11130193.html">swagger 部署(Mac )</a></p><p><a href="https://dandelioncloud.cn/article/details/1436927564110729218">Linux系列之安装Swagger UI教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile</title>
      <link href="/2022/04/02/Dockerfile/"/>
      <url>/2022/04/02/Dockerfile/</url>
      
        <content type="html"><![CDATA[<p>Dockerfile是Docker中用来<strong>自动化构建</strong>镜像的<strong>配置文件</strong>，在Dockerfile中，包含了构建镜像过程中需要执行的<strong>命令、参数以及其他操作</strong>，并且支持以<code>#</code>开头的注释行。</p><p>Dockerfile结构大致分为四部分：</p><ul><li>基础镜像信息</li><li>维护者信息</li><li>镜像操作指令</li><li>镜像启动时执行的命令</li></ul><h3 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h3><ul><li>docker从基础镜像<strong>运行一个容器</strong></li><li>执行一条指令并<strong>对容器做修改</strong> </li><li>执行类似docker commit的操作<strong>提交一个新的镜像层</strong></li><li>docker再<strong>基于刚提交的镜像</strong>运行一个新的容器</li><li>执行dockerfile中的下一条指令<strong>直到</strong>所有指令都<strong>执行完成</strong></li></ul><p>Dockerfile构建过程是以基础镜像为基础的，<strong>每一条指令构建一层镜像</strong>，因此每一条指令的内容，就是描述该层应当如何构建。以此，有了Dockerfile，我们可以方便的定制自己额外的需求，只需在Dockerfile里添加或者修改指令，重新构建即可。</p><h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><ul><li>编写一个 dockerfile 文件</li><li><code>docker build</code>构建成为一个镜像</li><li><code>docker run</code>运行镜像</li><li>Docker push 发布镜像（DockerHub、阿里云像仓库）</li></ul><h2 id="Dockerfile的编写规范"><a href="#Dockerfile的编写规范" class="headerlink" title="Dockerfile的编写规范"></a>Dockerfile的编写规范</h2><ol><li>每一个保留关键字(指令)都是必须是大写字母</li><li>执行从上到下顺序执行</li><li>#表示注释</li><li>每一个指令都会创建提交一个新的镜像层，并提交</li></ol><p><img src="/2022/04/02/Dockerfile/dkf1.jpg" alt="jpg"></p><h3 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h3><blockquote><p>FROM</p></blockquote><p>FROM 指令用于<strong>指定基础镜像</strong>，其后构建新镜像以此为基础进行构建。<code>FROM</code>指令是Dockerfile文件中除注释命令之外的<strong>第一条指令，也是必备的指令</strong>。如果在同一个Dockerfile中<strong>创建多个镜像</strong>时，可以使用多个<code>FROM</code>指令（每个镜像一次）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br><span class="line"># 或</span><br><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line"># 或</span><br><span class="line">FROM &lt;image&gt;:&lt;digest&gt;</span><br><span class="line"></span><br><span class="line">FROM ubuntu:14.04</span><br></pre></td></tr></table></figure><p>tag或digest是可选参数，如果不使用这两个值时，会使用latest版本的基础镜像。</p><blockquote><p>MAINTAINET</p></blockquote><p>指定维护者的信息。</p><blockquote><p>RUN</p></blockquote><p><strong>在镜像的构建过程中执行特定的命令</strong>（执行某些动作、安装系统软件、配置系统信息之类），并生成一个中间镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># shell格式</span><br><span class="line">RUN &lt;命令&gt;</span><br><span class="line"># exec格式</span><br><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果有多行命令尽量不要写多个<code>RUN</code>，因为Dockerfile中每一个指令都会构建一层，多少个<code>RUN</code>就构建了多少层镜像，会造成镜像的臃肿，还增加了构件部署的时间，可以使用换行符<code>\</code>。</p><blockquote><p>COPY</p></blockquote><p><code>COPY</code>命令用于将宿主机器上的的文件（Dockerfile所在目录的相对路径）复制到镜像内，如果目的位置不存在，Docker会自动创建。<code>源路径</code>所指定的源可以有多个,但必须是上下文根目录中的相对路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;源路径&gt;  &lt;目标路径&gt;</span><br><span class="line">COPY [&quot;&lt;源路径1&gt;&quot;,...   &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure><p>例如，把宿主机中的test.json文件复制到容器中&#x2F;usr&#x2F;src&#x2F;app&#x2F;目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY test.json /usr/src/app/</span><br></pre></td></tr></table></figure><blockquote><p>ADD</p></blockquote><p><code>ADD</code>指令的作用和<code>COPY</code>基本一致，但是在<code>COPY</code>基础上增加了一些功能，源路径可以是URL，也可以是 tar.gz。语法格式也和<code>COPY</code>一致。</p><blockquote><p>ENV</p></blockquote><p>ENV指令可以为镜像创建出来的容器声明环境变量。并且在Dockerfile中，ENV指令声明的环境变量会被后面的特定指令(即ENV、ADD、COPY、WORKDIR、EXPOSE、VOLUME、USER)解释使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line"># 或</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure><blockquote><p>environment</p></blockquote><p>compose file 中的 environment 节点用来为容器设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">web:</span><br><span class="line">  environment:</span><br><span class="line">    DEBUG: 1</span><br><span class="line"> </span><br><span class="line">等同于</span><br><span class="line">$ docker run -e DEBUG=1</span><br></pre></td></tr></table></figure><p>要把当前 shell 环境变量的值传递给容器的环境变量也很简单，去掉上面代码中的赋值部分就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web:</span><br><span class="line">  environment:</span><br><span class="line">    DEBUG:</span><br></pre></td></tr></table></figure><p>这种情况下，如果没有在当前的 shell 中导出环境变量 DEBUG，compose file 中会把它解释为 null。</p><p><strong>使用文件为容器设置多个环境变量</strong></p><p>如果觉得通过 environment 为容器设置环境变量不够过瘾，我们还可以像 docker -run 的 –env-file 参数一样通过文件为容器设置环境变量。</p><blockquote><p>WORKDIR</p></blockquote><p>格式: <code>WORKDIR /path/to/workdir</code></p><p>WORKDIR指令<strong>设置工作目录</strong>，它之后的RUN、CMD、ENTRYPOINT、COPY以及ADD指令都会在这个工作目录下运行。如果这个工作目录不存在，则会自动创建一个。<br>WORKDIR指令可在Dockerfile中多次使用。如果提供了相对路径，则它将相对于上一个WORKDIR指令的路径。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><p>输出结果是 &#x2F;a&#x2F;b&#x2F;c</p><blockquote><p>EXPOSE</p></blockquote><p>为构建的镜像设置监听端口，使容器在运行时监听。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port1&gt; [&lt;port2&gt;...]</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">EXPOSE 8080其实等价于docker run -p 8080,如果需要把8081端口映射到宿主机中的某个端口（如8088）以便外界访问时，则可以用docker run -p 8088:8080</span><br></pre></td></tr></table></figure><blockquote><p>USER</p></blockquote><p><code>USER</code>用于指定运行镜像所使用的用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER root</span><br></pre></td></tr></table></figure><p>使用<code>USER</code>指定用户后，Dockerfile中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>都将使用该用户执行。</p><blockquote><p>CMD</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br></pre></td></tr></table></figure><p><strong>指定启动容器时执行的命令</strong>，每个Dockerfile只能有一条<code>CMD</code>指令，如果指定了多条指令，则最后一条生效。</p><p>其作用是在启动容器的时候提供一个默认的命令项，如果用户执行<code>docker run</code>时提供了命令项，这个命令就会覆盖掉。</p><blockquote><p>VOLUME</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure><p>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p><blockquote><p>ENTRYPOINT</p></blockquote><p><strong>容器启动后执行的命令</strong>，这些命令不能被<code>docker run</code>提供的参数覆盖。和<code>CMD</code>一样，每个Dockerfile中只能有一个<code>ENTRYPOINT</code>，如果指定了多条指令，则最后一条生效。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>ONBUILD</p></blockquote><p><code>ONBUILD</code>用于配置当前所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure><h2 id="DockerFile实例"><a href="#DockerFile实例" class="headerlink" title="DockerFile实例"></a>DockerFile实例</h2><blockquote><p>编写Dockerfile</p></blockquote><p>构建MySQL镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:bionic-20190612</span><br><span class="line"></span><br><span class="line">LABEL maintainer xxxx@xxxx.com</span><br><span class="line"></span><br><span class="line">ENV MYSQL_USER=mysql \</span><br><span class="line">    MYSQL_VERSION=5.7 \</span><br><span class="line">    MYSQL_DATA_DIR=/var/lib/mysql \</span><br><span class="line">    MYSQL_RUN_DIR=/run/mysqld \</span><br><span class="line">    MYSQL_LOG_DIR=/var/log/mysql</span><br><span class="line"></span><br><span class="line">RUN apt-get update \</span><br><span class="line"> &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install -y mysql-server=$&#123;MYSQL_VERSION&#125;* \</span><br><span class="line"> &amp;&amp; rm -rf $&#123;MYSQL_DATA_DIR&#125; \</span><br><span class="line"> &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">EXPOSE 3306/tcp</span><br><span class="line"></span><br><span class="line">CMD [&quot;/usr/bin/mysqld_safe&quot;]</span><br></pre></td></tr></table></figure><blockquote><p> 运行构建命令构建</p></blockquote><p><code>docker build</code>命令用于使用Dockerfile创建镜像。<br> <strong>格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p><strong>常用OPTION如下：</strong>：</p><ul><li>–build-arg&#x3D;[]：设置镜像创建时的变量</li><li>-f：指定要使用的Dockerfile路径</li><li>-m：设置内存最大值</li><li>–force-rm：设置镜像过程中删除中间容器</li><li>–rm：设置镜像成功后删除中间容器</li><li>–tag, -t：镜像的名字及标签，通常 name:tag 或者 name 格式</li></ul><h2 id="参考原文链接"><a href="#参考原文链接" class="headerlink" title="参考原文链接"></a>参考原文链接</h2><p><a href="https://juejin.cn/post/7018794120428650533">必会系列！使用Dockerfile构建镜像</a><br><a href="https://juejin.cn/post/6844904081966759943">看完这篇,再也不用焦虑如何写dockerfile了</a><br><a href="https://juejin.cn/post/7031450887725776904">Docker高级学习(二) Dockerfile</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vernemq集群搭建、监控是真的好用</title>
      <link href="/2022/03/24/Vernemq%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E3%80%81%E7%9B%91%E6%8E%A7%E6%98%AF%E7%9C%9F%E7%9A%84%E5%A5%BD%E7%94%A8/"/>
      <url>/2022/03/24/Vernemq%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E3%80%81%E7%9B%91%E6%8E%A7%E6%98%AF%E7%9C%9F%E7%9A%84%E5%A5%BD%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>下载</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/vernemq/vernemq/releases/download/1.12.3/vernemq-1.12.3.centos7.x86_64.rpm</span><br></pre></td></tr></table></figure><p><strong>yum安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install ./vernemq-1.12.3.centos7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>安装完成后会自动生成配置文件**&#x2F;etc&#x2F;vernemq&#x2F;vernemq.conf**，修改配置文件，仅修改而不是全部替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启匿名访问，开启匿名访问后将不验证用户名及密码</span><br><span class="line">allow_anonymous = off</span><br><span class="line"># 若配置集群需要开发内部通讯</span><br><span class="line">allow_register_during_netsplit = on</span><br><span class="line">allow_publish_during_netsplit = on</span><br><span class="line">allow_subscribe_during_netsplit = on</span><br><span class="line">allow_unsubscribe_during_netsplit = on</span><br><span class="line"># 配置MQTT可连接地址以及端口0.0.0.0及代表任意IP可连接</span><br><span class="line">listener.tcp.default = 0.0.0.0:1883</span><br><span class="line">#服务器内网ip，集群通讯端口</span><br><span class="line">#这里值得注意的是我测试发现如果配置外网的IP集群是无法正常通信的</span><br><span class="line">listener.vmq.clustering = 172.xx.xxx.219:44053</span><br><span class="line">#VerneMQweb监控页面以及端口</span><br><span class="line">listener.http.default= 0.0.0.0:8085</span><br><span class="line">#集群中节点名称，避免重复</span><br><span class="line">nodename = vmqNode1@172.xx.xxx.219</span><br></pre></td></tr></table></figure><p>如果未开启匿名访问，我们就需要为<strong>Vernemq</strong>添加相关的账号密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmq-passwd -c /etc/vernemq/vmq.passwd admin #回车键 输入密码并验证 19491001</span><br></pre></td></tr></table></figure><p>接下来就是配置topic的读写权限，默认状态下允许所有用户对所有的topic可读写。</p><p>但安全和规范起见，建议大家规定各任务之间不同的topic并对权限加以控制。修改配置文件：&#x2F;etc&#x2F;vernemq&#x2F;vmq.acl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#添加如下内容</span><br><span class="line">topic read $SYS/## ACL for user &#x27;admin&#x27;user admintopic test/#</span><br><span class="line"></span><br><span class="line">这里的#代表统配，例如test/#代表test及以下所有topic</span><br></pre></td></tr></table></figure><p>启动vernemq</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start vernemq</span><br></pre></td></tr></table></figure><p>若为集群则使用如下命令加入任意集群节点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vmq-admin cluster join discovery-node=vmqNode1@172.xx.xxx.219   #节点名称</span><br></pre></td></tr></table></figure><p>查看节点状态：<code>vmq-admin cluster show</code>，或者通过web监控页面查看集群以及节点状态，访问如下地址：http(s):&#x2F;&#x2F;ip:8085&#x2F;status，这里的端口为上方配置文件中配置的listener.http.default信息中的端口。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><strong>启动(除了上面的之外):</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vernemq start|stop|restart(成功) 或者 /etc/init.d/vernemq start|stop|restart(应该还要配置，参考)</span><br></pre></td></tr></table></figure><p><strong>版本升级</strong></p><ol><li>下载升级版本的二进制文件</li><li>执行 rpm -Uvh vernemq-[version].centos7.x86_64.rpm</li><li>重启vernemq 服务</li><li>注意：要看下旧的进程是否存在，存在的话，需要kill 进程，重新启动</li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote><p>MQTTBox请求(订阅&#x2F;发布)</p></blockquote><p>通过下面连接添加谷歌商店拓展应用<strong>MQTTBox</strong></p><p><code>https://www.hivemq.com/blog/mqtt-toolbox-mqttbox/</code></p><p><strong>MQTTBox</strong>使用参考文章：</p><p><a href="https://blog.csdn.net/qq_20042935/article/details/101195038">Mac 下MQTT免费测试工具MQTTBox</a></p><blockquote><p>node.js请求(订阅&#x2F;发布)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">报错：npm WARN saveError ENOENT: no such file or directory, open &#x27;package.json&#x27;</span><br><span class="line">处理方式：npm install -y</span><br><span class="line"></span><br><span class="line">报错：Error: Cannot find module &#x27;mqtt&#x27;</span><br><span class="line">处理方式：npm install mqtt</span><br><span class="line"></span><br><span class="line">完整操作</span><br><span class="line"># mkdir -p node</span><br><span class="line"># cd node</span><br><span class="line"># npm install -y</span><br><span class="line"># npm install mqtt</span><br><span class="line"># vi app.js</span><br><span class="line"># vi publish.js</span><br><span class="line"># node app.js</span><br><span class="line"># node publish.js</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">start</span><br><span class="line">connected</span><br><span class="line">hello</span><br><span class="line">good man</span><br></pre></td></tr></table></figure><p><strong>app.js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var mqtt = require(&#x27;mqtt&#x27;);</span><br><span class="line">var client  = mqtt.connect(&#x27;mqtt://47.xx.xxx.104:1883&#x27;,&#123;username:&#x27;admin&#x27;,password:&#x27;19491001&#x27;&#125;);</span><br><span class="line"></span><br><span class="line">client.on(&#x27;connect&#x27;, function () &#123;</span><br><span class="line">    console.log(&quot;connected&quot;);</span><br><span class="line">    client.subscribe(&#x27;hello&#x27;);</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        client.publish(&#x27;presence&#x27;, &#x27;Hello mqtt&#x27;)</span><br><span class="line">    &#125;,10)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(&#x27;message&#x27;, function (topic, message) &#123;</span><br><span class="line">    // message is Buffer</span><br><span class="line">    console.log(topic);</span><br><span class="line">    console.log(message.toString());</span><br><span class="line">    client.end()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;start&quot;);</span><br></pre></td></tr></table></figure><p><strong>publish.js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var mqtt = require(&#x27;mqtt&#x27;);</span><br><span class="line">var client  = mqtt.connect(&#x27;mqtt://47.xx.xxx.104:1883&#x27;,&#123;username:&#x27;admin&#x27;,password:&#x27;19491001&#x27;&#125;);</span><br><span class="line"></span><br><span class="line">setInterval(function ()&#123;</span><br><span class="line">     client.publish(&#x27;hello&#x27;,&#x27;good man&#x27;,&#123;qos:1,retain:true&#125;)</span><br><span class="line">&#125;,2000);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果<code>allow_anonymous = on</code>，那么只需要<code>mqtt.connect(&#39;mqtt://47.xx.xxx.104:1883&#39;)</code></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/weixin_39767645/article/details/111671642">mosquitto查看订阅记录_MQTT还在使用mosquitto？Vernemq集群搭建、监控是真的好用</a></p><p><a href="https://kebingzao.com/2018/06/03/vernemq-verify/">webrtc 的 signal 服务器 VerneMQ 的权限校验</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当访问不到类似http:xxxx:9001内容时</title>
      <link href="/2022/03/24/%E5%BD%93%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%88%B0%E7%B1%BB%E4%BC%BChttp-xxxx-9001%E5%86%85%E5%AE%B9%E6%97%B6/"/>
      <url>/2022/03/24/%E5%BD%93%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%88%B0%E7%B1%BB%E4%BC%BChttp-xxxx-9001%E5%86%85%E5%AE%B9%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<ol><li>查看是否使用阿里云，确认安全组是否开启端口</li><li>查看防火墙端口是否开启<br><code>https://www.cnblogs.com/zxg-blog/p/9835263.html</code></li><li>查看netstat -lnpt | grep “端口” 查看端口是否允许</li><li>查看是否是0.0.0.0，而非127.0.0.1</li><li>通过telnet 0.0.0.0 9001</li><li>通过curl 0.0.0.0 9001</li><li>通过ping 0.0.0.0 9001</li><li>端口是否被占用</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB常见操作</title>
      <link href="/2022/03/24/MongoDB%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/03/24/MongoDB%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="评价查询操作符"><a href="#评价查询操作符" class="headerlink" title="评价查询操作符"></a>评价查询操作符</h2><h3 id="mod-取模计算"><a href="#mod-取模计算" class="headerlink" title="$mod - 取模计算"></a>$mod - 取模计算</h3><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.c1.find()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af85afa87dc1bed94330&quot;),&quot;age&quot;:7,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af89afa87dc1bed94331&quot;),&quot;age&quot;:8,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af8cafa87dc1bed94332&quot;),&quot;age&quot;:6,&quot;length_1&quot;:30&#125;</span><br></pre></td></tr></table></figure><p>查询age取模6等于1的数据，如下面的代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.c1.find(&#123;age:&#123;$mod:[6,1]&#125;&#125;)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af85afa87dc1bed94330&quot;),&quot;age&quot;:7,&quot;length_1&quot;:30&#125;</span><br></pre></td></tr></table></figure><p>可以看出，只显示age取模6等于1的数据，其他不符合规则的数据并没有显示出来。</p><h2 id="比较查询操作符"><a href="#比较查询操作符" class="headerlink" title="比较查询操作符"></a>比较查询操作符</h2><h3 id="gt-大于"><a href="#gt-大于" class="headerlink" title="$gt  - 大于"></a>$gt  - 大于</h3><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.c1.find()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af85afa87dc1bed94330&quot;),&quot;age&quot;:7,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af89afa87dc1bed94331&quot;),&quot;age&quot;:8,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af8cafa87dc1bed94332&quot;),&quot;age&quot;:6,&quot;length_1&quot;:30&#125;</span><br></pre></td></tr></table></figure><p>查询age的值不等于8的数据，如下面的代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.c1.find(&#123;age:&#123;$gt:6&#125;&#125;)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af85afa87dc1bed94330&quot;),&quot;age&quot;:7,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af89afa87dc1bed94331&quot;),&quot;age&quot;:8,&quot;length_1&quot;:30&#125;</span><br></pre></td></tr></table></figure><p>可以看出，只显示age大于6的数据，age等于6的数据没有显示出来。</p><h3 id="lte-小于等于"><a href="#lte-小于等于" class="headerlink" title="$lte - 小于等于"></a>$lte - 小于等于</h3><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.c1.find()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af85afa87dc1bed94330&quot;),&quot;age&quot;:7,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af89afa87dc1bed94331&quot;),&quot;age&quot;:8,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af8cafa87dc1bed94332&quot;),&quot;age&quot;:6,&quot;length_1&quot;:30&#125;</span><br></pre></td></tr></table></figure><p>查询age的值不等于8的数据，如下面的代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.c1.find(&#123;age:&#123;$lte:7&#125;&#125;)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af85afa87dc1bed94330&quot;),&quot;age&quot;:7,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af8cafa87dc1bed94332&quot;),&quot;age&quot;:6,&quot;length_1&quot;:30&#125;</span><br></pre></td></tr></table></figure><p>可以看出，只显示age小于等于7的数据，age等于8的数据没有显示出来。</p><h3 id="in-包含"><a href="#in-包含" class="headerlink" title="$in - 包含"></a>$in - 包含</h3><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.c1.find()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af85afa87dc1bed94330&quot;),&quot;age&quot;:7,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af89afa87dc1bed94331&quot;),&quot;age&quot;:8,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af8cafa87dc1bed94332&quot;),&quot;age&quot;:6,&quot;length_1&quot;:30&#125;</span><br></pre></td></tr></table></figure><p>查询age的值在7、8范围内的数据，如下面的代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.c1.find(&#123;age:&#123;$in:[7,8]&#125;&#125;)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af85afa87dc1bed94330&quot;),&quot;age&quot;:7,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af89afa87dc1bed94331&quot;),&quot;age&quot;:8,&quot;length_1&quot;:30&#125;</span><br></pre></td></tr></table></figure><p>可以看出只显示age等于7或8的数据，其他不符合规则的数据并没有显示出来。</p><h3 id="nin-不包含"><a href="#nin-不包含" class="headerlink" title="$nin - 不包含"></a>$nin - 不包含</h3><h3 id="lt-小于"><a href="#lt-小于" class="headerlink" title="$lt - 小于"></a>$lt - 小于</h3><h3 id="gte-大于等于"><a href="#gte-大于等于" class="headerlink" title="$gte - 大于等于"></a>$gte - 大于等于</h3><h3 id="ne-不等于"><a href="#ne-不等于" class="headerlink" title="$ne - 不等于"></a>$ne - 不等于</h3><h3 id="eq-等于"><a href="#eq-等于" class="headerlink" title="$eq - 等于"></a>$eq - 等于</h3><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.c1.find()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af85afa87dc1bed94330&quot;),&quot;age&quot;:7,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af89afa87dc1bed94331&quot;),&quot;age&quot;:8,&quot;length_1&quot;:30&#125;&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af8cafa87dc1bed94332&quot;),&quot;age&quot;:6,&quot;length_1&quot;:30&#125;</span><br></pre></td></tr></table></figure><p>查询age的值不等于8的数据，如下面的代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.c1.find(&#123;age:&#123;$eq:7&#125;&#125;)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fb4af85afa87dc1bed94330&quot;),&quot;age&quot;:7,&quot;length_1&quot;:30&#125;</span><br></pre></td></tr></table></figure><h2 id="数组更新操作符"><a href="#数组更新操作符" class="headerlink" title="数组更新操作符"></a>数组更新操作符</h2><h3 id="pushAll-用法同-push一样，只是-pushAll一次可以追加多个值到一个数组字段内。"><a href="#pushAll-用法同-push一样，只是-pushAll一次可以追加多个值到一个数组字段内。" class="headerlink" title="$pushAll - 用法同$push一样，只是$pushAll一次可以追加多个值到一个数组字段内。"></a>$pushAll - 用法同$push一样，只是$pushAll一次可以追加多个值到一个数组字段内。</h3><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.t3.find()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fe67b008414d282f712fae6&quot;),&quot;userid&quot;:3,&quot;name&quot;:[&quot;wangwenlong&quot;]&#125;</span><br></pre></td></tr></table></figure><p>可以看到当前别名有1个，是”wangwenlong”，接下来将”N1”和”N2”名字加入到name字段数据组里，如下面的代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.t3.update(&#123;&quot;userid&quot;:3&#125;,&#123;$pushAll:&#123;&quot;name&quot;:[&quot;N1&quot;,&quot;N2&quot;]&#125;&#125;)</span><br><span class="line">&gt;db.t3.find()</span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fe67b008414d282f712fae6&quot;),&quot;name&quot;:[&quot;wangwenlong&quot;,&quot;N1&quot;,&quot;N2&quot;],&quot;userid&quot;:3&#125;</span><br></pre></td></tr></table></figure><p>可以看到更新后当前别名里又多了2个，分别是”N1”和”N2”。</p><h3 id="pullAll-用法同-pull一样，只是-pullAll可以一次删除数组内的多个值。"><a href="#pullAll-用法同-pull一样，只是-pullAll可以一次删除数组内的多个值。" class="headerlink" title="$pullAll - 用法同$pull一样，只是$pullAll可以一次删除数组内的多个值。"></a>$pullAll - 用法同$pull一样，只是$pullAll可以一次删除数组内的多个值。</h3><p><strong>注意：</strong>  数组更新操作符只能更新数组，如果键值是乱序的会报错。[“xiao ming”, “xiao dong”, “xiao hong “]正确，[0 &#x3D;&gt; “xiao ming”, 2 &#x3D;&gt; “xiao dong”, 5 &#x3D;&gt;  “xiao hong “]报错。</p><h2 id="数组更新操作符-1"><a href="#数组更新操作符-1" class="headerlink" title="数组更新操作符"></a>数组更新操作符</h2><h3 id="set-设置某一个字段的值。"><a href="#set-设置某一个字段的值。" class="headerlink" title="$set - 设置某一个字段的值。"></a>$set - 设置某一个字段的值。</h3><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.t3.find()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fe676348414d282f712fae4&quot;),&quot;name&quot;:&quot;wangwenlong&quot;,&quot;age&quot;:35&#125;</span><br></pre></td></tr></table></figure><p>可以看到当前年龄是35岁，接下来将age调整为40，如下面的代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.t3.update(&#123;name:&quot;wangwenlong&quot;&#125;,&#123;$set:&#123;age:40&#125;&#125;)</span><br><span class="line">&gt;db.t3.find()</span><br><span class="line">结果：</span><br><span class="line">&#123;&quot;_id&quot;:ObjectId(&quot;4fe676348414d282f712fae4&quot;),&quot;name&quot;:&quot;wangwenlong&quot;,&quot;age&quot;:40&#125;&gt;</span><br></pre></td></tr></table></figure><p>可以看到，更新后年龄从30变成了40。</p><p>更多内容，可以查看<a href="https://www.mongodb.org.cn/manual/230.html">mongoDB</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT 协议是个啥？这篇文章告诉你！</title>
      <link href="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/"/>
      <url>/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-MQTT-协议"><a href="#什么是-MQTT-协议" class="headerlink" title="什么是 MQTT 协议"></a>什么是 MQTT 协议</h2><p>MQTT 协议的全称是 <strong>Message Queuing Telemetry Transport</strong>，翻译为消息队列传输探测，它是 ISO 标准下的一种基于<strong>发布 - 订阅</strong>模式的消息协议，它是基于 TCP&#x2F;IP 协议簇的，它是为了改善网络设备硬件的性能和网络的性能来设计的。MQTT 一般多用于 IoT 即物联网上，广泛应用于工业级别的应用场景，比如汽车、制造、石油、天然气等。</p><p><strong>ISO</strong>标准是指由『 国际标准化组织 (International Organization for Standardization)， <em>ISO</em> 』制订的标准。</p><h2 id="MQTT-基础"><a href="#MQTT-基础" class="headerlink" title="MQTT 基础"></a>MQTT 基础</h2><p>上面我们解释了 MQTT 协议的基本概念，MQTT 协议总结一点就是一种<strong>轻量级的二进制协议</strong>，MQTT 协议与 HTTP 相比具有一个明显的优势：<strong>数据包开销较小</strong>，数据包开销小就意味着更容易进行网络传输。还有一个优势就是 MQTT 在客户端容易实现，而且具有易用性，非常适合当今资源有限的设备。</p><blockquote><p>你可能对这些概念有些讳莫如深，为什么具有 xxx 这种特性呢？这就需要从 MQTT 的设计说起了。</p></blockquote><p>MQTT 协议由 Andy Stanford-Clark (IBM) 和 Arlen Nipper（Arcom，现为 Cirrus Link）于 1999 年发明。 他们需要一种通过卫星连接石油管道的协议，以最大限度地减少电池损耗和带宽。所以他们为这个协议规定了几种要求：</p><ul><li>这个协议必须易于实现；</li><li>这个协议中的数据必须易于传输，消耗成本小；</li><li>这个协议必须提供服务质量管理；</li><li>这个协议必须支持连续的会话控制</li><li>假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</li></ul><p>这些设计也是 MQTT 的精髓所在，MQTT 经过不断的发展，已经成为了物联网 IoT 所必备的一种消息探测协议，官方强烈推荐使用的版本是 MQTT 5。</p><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布 - 订阅模式"></a>发布 - 订阅模式</h3><p>发布 - 订阅模式我相信接触消息中间件架构的同学都听过，这是一种传统的<strong>客户端 - 服务器</strong>架构的替代方案。</p><p>一般传统的客户端-服务器是客户端能够直接和服务器进行通信，但是发布 - 订阅模式 <code>pub/sub</code>就不一样了，发布订阅模式会将<strong>发送消息的发布者</strong> <code>publisher</code>与<strong>接收消息的订阅者</strong> <code>subscribers</code>进行分离，publisher 与 subscribers 并不会直接通信，他们甚至都不清楚对方是否存在，他们之间的交流由第三方组件 <code>broker</code> 代理。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt1.jpg" alt="jpg"></p><p>pub&#x2F;sub 最重要的方面是 publisher 与 subscriber 的解藕，这种耦合度有下面三个维度：</p><ul><li>空间解耦：publisher 与 subscriber 并不知道对方的存在，例如不会有 IP 地址和端口的交互，也更不会有消息的交互。</li><li>时间解藕：publisher 与 subscriber 并不一定需要同时运行。</li><li>同步 <code>Synchronization</code> 解藕：两个组件的操作比如 publish 和 subscribe 都不会在发布或者接收过程中产生中断。</li></ul><p>总之，发布&#x2F;订阅模式消除了传统客户-服务器之间的直接通信，把通信这个操作交给了 broker 进行代理，并在空间、时间、同步三个维度上进行了解藕。</p><h3 id="可拓展性"><a href="#可拓展性" class="headerlink" title="可拓展性"></a>可拓展性</h3><p>pub&#x2F;sub 比传统的客户端-服务器模式有了更好的拓展，这是由于 broker 的高度<code>并行化</code>，并且是基于<code>事件驱动</code>的模式。可拓展性还体现在<strong>消息的缓存</strong>和<strong>消息的智能路由</strong>，还可以通过集群代理来实现数百万的连接，使用负载均衡器将负载分配到更多的单个服务器上，这就是 MQTT 的深度应用了。</p><blockquote><p>你可能不明白什么是事件驱动，我在这里解释下事件驱动的概念。</p></blockquote><p>事件驱动是一种<code>编程范式</code>，编程范式是软件工程中的概念，<strong>它指的是一种编程方法或者说程序设计方式</strong>，比如说面向对象编程和面向过程编程就是一种编程范式，事件驱动中的程序流程会由诸如用户操作（点击鼠标、键盘）、传感器输出或者从其他程序或传递的消息事件决定。事件驱动编程是图形用户界面和其他应用程序比如 Web 中使用的主要范式，这些应用程序能够响应用户输入执行某些操作为中心，这同时也适用于驱动程序的编程。</p><h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>在 pub&#x2F;sub 的架构模式中，broker 扮演着至关重要的作用，其中非常重要的一点就是 broker 能够对消息进行过滤，使每个订阅者只接收自己感兴趣的消息。</p><p>broker 有几个可以过滤的选项</p><ul><li><strong>基于主题的过滤</strong></li></ul><p>MQTT 是基于 subject 的消息过滤的，每条消息都会有一个 topic ，接收客户端会向 borker 订阅感兴趣的 topic，订阅后，broker 就会确保客户端收到发布到 topic 中的消息。</p><ul><li><strong>基于内容的过滤</strong></li></ul><p>在基于内容的过滤中，broker 会根据特定的内容过滤消息，接受客户端会经过过滤他们感兴趣的内容。这种方法的一个显著的缺点就是必须事先知道消息的内容，不能加密或者轻易修改。</p><ul><li><strong>基于类型的过滤</strong></li></ul><p>在使用面向对象的语言时，基于消息（事件）的类型过滤是一种比较常见的过滤方式。</p><p>为了发布&#x2F;订阅系统的挑战，MQTT 具有三个服务质量级别，你可以指定<strong>消息</strong>从客户端传到 broker 或者从 broker 传到客户端，在 topic 的订阅中，会存在 topic 没有 subscriber 订阅的情况，作为 broker 必须知道如何处理这种情况。</p><h2 id="MQTT-与消息队列的区别"><a href="#MQTT-与消息队列的区别" class="headerlink" title="MQTT 与消息队列的区别"></a>MQTT 与消息队列的区别</h2><p>我们现在知道，MQTT 是一种消息队列传输探测协议，这种协议是看似是以消息队列为基础，但却与消息队列有所差别。</p><p>在传统的消息队列模式中，一条消息会存储在消息队列中等待被消费，每个传入的消息都存储在消息队列中，直到它被客户端（通常称之为消费者）所接收，如果没有客户端消费消息的话，这条消息就会存在消息队列中等待被消费。但是<strong>在消息队列中，不会存在消息没有客户端消费的情况，但是在 MQTT 中，确存在 topic 无 subscriber 订阅的情况</strong>。</p><p>在传统的消息队列模式中，一条消息只能被一个客户端所消费，<code>负载</code>会分布在队列的每个消费者之间；而在 MQTT 中，<strong>每个订阅者都会受到消息</strong>，每个订阅者有相同的负载。</p><p>在传统的消息队列模式中，必须使用单独的命令来显式创建队列，只有队列创建后，才可以生产或者消费消息；而在 MQTT 中，topic 比较灵活，可以即时创建。</p><blockquote><p>HiveMQ 现在是开源的，HiveMQ 社区版实现了 MQTT broker 规范，并兼容了 MQTT 3.1、3.1.1 和 MQTT 5。HiveMQ MQTT Client 是一个基于 Java 的 MQTT 客户端实现，兼容 MQTT 3.1.1 和 MQTT 5。这两个项目都可以在 HiveMQ 的 github <a href="https://link.juejin.cn/?target=https://github.com/hivemq">github.com&#x2F;hivemq</a> 上找到。</p></blockquote><p>我们知道，broker 将 publisher 和 subscriber 进行分离，因此客户端的连接由 broker 代理，所以在我们深入理解 MQTT 之前，我们需要先知道客户端和代理的含义。</p><h2 id="MQTT-重要概念"><a href="#MQTT-重要概念" class="headerlink" title="MQTT 重要概念"></a>MQTT 重要概念</h2><h3 id="MQTT-client"><a href="#MQTT-client" class="headerlink" title="MQTT client"></a>MQTT client</h3><p>当我们讨论关于客户端的概念时，一般指的就是 <strong>MQTT Client</strong>，publisher 和 subscriber 都属于 MQTT Client。之所以有发布者和订阅者这个概念，其实是一种相对的概念，就是指当前客户端是在发布消息还是在接收消息，<strong>发布和订阅的功能也可以由同一个 MQTT Client 实现</strong>。</p><p>MQTT 客户端是指<strong>运行 MQTT 库并通过网络连接到 MQTT broker 的任何设备</strong>，这些设备可以从微控制器到成熟的服务器。基本上，任何使用 TCP&#x2F;IP 协议使用 MQTT 设备的都可以称之为 MQTT Client。MQTT 协议的客户端实现非常简单直接。易于实施是 MQTT 非常适合小型设备的原因之一。 MQTT 客户端库可用于多种编程语言。 例如，Android、Arduino、C、C++、C#、Go、iOS、Java、JavaScript 和 .NET。</p><h3 id="MQTT-broker"><a href="#MQTT-broker" class="headerlink" title="MQTT broker"></a>MQTT broker</h3><p>与 MQTT client 对应的就是 MQTT broker，broker 是任何发布&#x2F;订阅机构的核心，根据实现的不同，代理可以处理多达数百万连接的 MQTT client。</p><p>broker 负责接收所有消息，过滤消息，确定是哪个 client 订阅了哪条消息，并将消息发送给对应的 client，broker 还负责保存会话数据，这些数据包括订阅的和错过的消息。broker 还负责客户端的身份验证和授权。</p><h3 id="MQTT-Connection"><a href="#MQTT-Connection" class="headerlink" title="MQTT Connection"></a>MQTT Connection</h3><p>MQTT 是基于 TCP&#x2F;IP 协议基础之上的，所以 MQTT 的 client 和 broker 都需要 TCP&#x2F;IP 协议的支持。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt2.jpg" alt="jpg"></p><p>MQTT 的连接总是在 client 和 broker 之间进行，client 和 client 之间并<strong>不会</strong>相互连接。如果要发起连接的话，那么 client 就会向 broker 发起 <code>CONNECT</code> 消息，代理会使用 <code>CONNACK</code> 消息和状态码进行响应。一旦 client 和 broker 的连接建立后，broker 就会使客户端的连接一直处于打开状态，直到 client 发出断开命令或者连接中断。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt3.jpg" alt="jpg"></p><h2 id="消息报文"><a href="#消息报文" class="headerlink" title="消息报文"></a>消息报文</h2><p>MQTT 的消息报文主要分为 CONNECT 和 CONNACK 消息。</p><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>我们上面提到了为了初始化连接，需要 client 向 broker 发送 CONNECT 消息，如果这个 CONNECT 消息格式错误或者打开套接字（因为基于 TCP&#x2F;IP 协议栈需要初始化 Socket 连接）时间过长，亦或是发送连接消息时间过长的话，broker 就会关闭这条连接。</p><p>一个 MQTT 客户端发送一条 CONNECT 连接，这条 CONNECT 连接可能会包含下面这些信息：</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt4.jpg" alt="jpg"></p><p>我这里解释一下这些信息都是什么概念</p><ul><li><code>ClientId</code>：显而易见，这个就是每个客户端的 ID 标识，也就是连接到 MQTT broker 的每个 client。这个 ID 应该是每个 client 和 broker 唯一的，如果你不需要 broker 持有状态的话，你可以发送一个空的 ClientId，空的 ClientId 会没有任何状态。在这种情况下，<strong>ClientSession</strong> 需要设置为 true，否则将会拒绝连接。</li></ul><blockquote><p>clientSession 是什么我们下面会说。</p></blockquote><ul><li><code>CleanSession</code>：CleanSession 会话标志会告诉 broker client 是否需要建立持久会话。在持久会话 （CleanSession &#x3D; false）中，broker 存储 client 的所有订阅以及<strong>服务质量(Qos)</strong> 是 1 或 2 订阅的 client 的所有丢失的消息。如果会话不是持久的（CleanSession &#x3D; true），那么 broker 则不会为 client 存储任何内容并且会清除先前持久会话中的所有信息。</li><li><code>Username/Password</code> ：MQTT 会发送 username 和 password 进行 client 认证和授权。如果此信息没有经过加密或者 hash ，那么密码将会以纯文本的形式发送。所以，一般强烈建议 username 和 password 要经过加密安全传输。像 HiveMQ 这样的 broker 可以与 SSL 证书进行身份验证，因此不需要用户名和密码。</li><li><code>LastWillxxx</code> ：LastWillxxx 表示的是遗愿，client 在连接 broker 的时候将会设立一个遗愿，这个遗愿会保存在 broker 中，当 client 因为<strong>非正常原因</strong>断开与 broker 的连接时，broker 会将遗愿发送给订阅了这个 topic（订阅遗愿的 topic）的 client。</li><li><code>keepAlive</code>：keepAlive 是 client 在连接建立时与 broker 通信的时间间隔，通常以秒为单位。这个时间指的是 client 与 broker 在不发送消息下所能承受的最大时长。</li></ul><p>在聊完 client 与 broker 之间发送建立连接的 CONNECT 消息后，我们再来聊一下 broker 需要对 CONNECT 进行确认的 CONNACK 消息。</p><h3 id="CONNACK"><a href="#CONNACK" class="headerlink" title="CONNACK"></a>CONNACK</h3><p>当 broker 收到 CONNECT 消息时，它有义务回复 CONNACK 消息进行响应。CONNACK 消息包括两部分内容</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt5.jpg" alt="jpg"></p><ul><li><p><code>SessionPresent</code>：会话当前标识，这个标志会告诉 client 当前 broker 是否有一个持久性会话与 client 进行交互。SessionPresent 标志和 CleanSession 标志有关，当 client 在 CleanSession 设置为 true 的情况下连接时，SessionPresent 始终为 false，因为没有持久性会话可以使用。如果 CleanSession 设置为 false，则有两种可能性，如果 ClientId 的会话信息可用，并且 broker 已经存储了会话信息，那么 SessionPresent 为 true，否则如果没有 ClientId 的任何会话信息，那么 SessionPresent 为 false。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt6.jpg" alt="jpg"></p></li><li><p><code>ReturnCode</code>：CONNACK 消息中的第二个标志是连接确认标志。这个标志包含一个返回码，告诉客户端连接尝试是否成功。连接确认标志有下面这些选项。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt7.jpg" alt="jpg"></p></li></ul><p>关于每个连接的详细说明，可以参考 <a href="https://link.juejin.cn/?target=https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html%23_Toc398718035">docs.oasis-open.org&#x2F;mqtt&#x2F;mqtt&#x2F;v…</a></p><h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>当 MQTT client 在连接到 broker 之后就可以发送消息了，MQTT 使用的是基于 topic 主题的过滤。每条消息都应该包含一个 topic ，broker 可以使用 topic 将消息发送给感兴趣的 client。除此之外，每条消息还会包含一个<code>负载(Payload)</code>，Payload 中包含要以字节形式发送的数据。</p><p>MQTT 是数据无关性的，也就是说数据是由发布者 - publisher 决定要发送的是 XML 、JSON 还是二进制数据、文本数据。</p><p>MQTT 中的 PUBLISH 消息结构如下。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt8.jpg" alt="jpg"></p><ul><li><code>Packet Identifier</code>：这个 PacketId 标识在 client 和 broker 之间唯一的消息标识。packetId 仅与大于零的 Qos 级别相关。</li><li><code>TopicName</code>：主题名称是一个简单的字符串，<code>/</code> 代表着分层结构。</li><li><code>Qos</code>：这个数字表示的是服务质量水平，服务质量水平有三个等级：0、1 和 2，服务级别决定了消息到达 client 或者 broker 的保证类型，来决定消息是否丢失。</li><li><code>RetainFlag</code>：这个标志表示 broker 将最近收到的一条 RETAIN 标志位为<code>true</code>的消息保存在服务器端（内存或者文件）。</li></ul><blockquote><p>MQTT 服务器只会为每一个 Topic 保存最近收到的一条 RETAIN 标志位为<code>true</code>的消息。也就是说，如果MQTT 服务器上已经为某个 Topic 保存了一条 Retained 消息，当客户端再次发布一条新的 Retained 消息时，那么服务器上原来的那条消息会被覆盖。</p></blockquote><ul><li><code>Payload</code>：这个是每条消息的实际内容。MQTT 是数据无关性的。可以发送任何文本、图像、加密数据以及二进制数据。</li><li><code>Dupflag</code>：这个标志表示该消息是重复的并且由于预期的 client 或者 broker 没有确认所以重新发送了一次。这个标志仅仅与 Qos 大于 0 相关。</li></ul><p>当 client 向 broker 发送消息时，broker 会读取消息，根据 Qos 的级别进行消息确认，然后处理消息。处理消息其实就是确定哪些 subscriber 订阅了 topic 并将消息发送给他们。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt9.jpg" alt="jpg"></p><p>最初发布消息的 client 只关心将 PUBLISH 消息发送给 broker，一旦 broker 收到 PUBLISH 消息，broker 就有责任将其传递给所有 subscriber。发布消息的 client 不会知道是否有人对发布的消息感兴趣，同时也不知道多少 client 从 broker 收到了消息。</p><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>client 会向 broker 发送 SUBSCRIBE 消息来接收有关感兴趣的 topic，这个 SUBSCRIBE 消息非常简单，它包含了一个唯一的数据包标识和一个订阅列表。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt10.jpg" alt="jpg"></p><ul><li><code>Packet Identifier</code>：这个 PacketId 和上面的 PacketId 一样，都表示消息的唯一标识符。</li><li><code>ListOfSubscriptions</code>：SUBSCRIBE 消息可以包含一个 client 的多个订阅，每个订阅都会由一个 topic 和一个 Qos 构成。订阅消息中的 topic 可以包含通配符。</li></ul><h3 id="确认消息"><a href="#确认消息" class="headerlink" title="确认消息"></a>确认消息</h3><p>client 在向 broker 发送 SUBSCRIBE 消息后，为了确认每个订阅，broker 会向 client 发送 SUBACK 确认消息。这个 SUBACK 包含原始 SUBSCRIBE 消息的 packetId 和返回码列表。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt11.jpg" alt="jpg"></p><p>其中</p><ul><li><code>Packet Identifier</code> ：这个数据包标识符和 SUBSCRIBE 中的相同。</li><li><code>ReturnCode</code>：broker 为每个接收到的 SUBSCRIBE 消息的 topic&#x2F;Qos 对发送一个返回码。例如，如果 SUBSCRIBE 消息有五个订阅消息，则 SUBACK 消息包含五个返回码作为响应。</li></ul><p>到现在我们已经探讨过了三种消息类型，发布 - 订阅 - 确认消息，这三种消息的示意图如下。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt12.jpg" alt="jpg"></p><h3 id="退订"><a href="#退订" class="headerlink" title="退订"></a>退订</h3><p>SUBSCRIBE 消息对应的是 <code>UNSUBSCRIBE</code> 消息，这条消息发送后，broker 会删除关于 client 的订阅。所以，UNSUBSCRIBE 消息与 SUBSCRIBE 消息类似，都具有 packetId 和 topic 列表。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt13.jpg" alt="jpg"></p><h3 id="确认退订"><a href="#确认退订" class="headerlink" title="确认退订"></a>确认退订</h3><p>取消订阅也需要 broker 的确认，此时 broker 会向 client 发送一个 <code>UNSUBACK</code> 消息，这个 UNSUBACK 消息非常简单，只有一个 packetId 数据标识符。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt14.jpg" alt="jpg"></p><p>退订和确认退订的流程如下。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt15.jpg" alt="jpg"></p><p>当 client 收到来自 broker 的 UNSUBACK 消息后，就可以认为 UNSUBSCRIBE 消息中的订阅被删除了。</p><h2 id="聊聊-Topic"><a href="#聊聊-Topic" class="headerlink" title="聊聊 Topic"></a>聊聊 Topic</h2><p>聊了这么多关于 MQTT 的内容，但是我们还没有好好聊过 Topic。在 MQTT 中，Topic 是指 broker 为每个连接的 client 过滤消息的 <code>UTF-8</code> 字符串。Topic 是一种分层的结构，可以由一个或者多个 Topic 组成。每个 Topic 由 <code>/</code> 进行分割。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt16.jpg" alt="jpg"></p><p>与传统的消息队列相比，MQTT Topic 非常轻量级，client 在发布或订阅之前不需要先创建所需要的 Topic，broker 在接收每个 Topic 前不用进行初始化操作。</p><p><strong>通配符</strong></p><p>当客户端订阅 Topic 时，它可以订阅已发布消息的确切 Topic，也可以使用通配符来同时订阅多个 Topic。通配符有两种：<strong>单级和多级</strong>。</p><h3 id="单级通配符"><a href="#单级通配符" class="headerlink" title="单级通配符"></a>单级通配符</h3><p>单级通配符可以替换 Topic 的一个级别，<code>+</code> 号代表 Topic 中的单级通配符。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt17.jpg" alt="jpg"></p><p>如果 Topic 包含任意字符串而不是通配符，则任何 Topic 都能够和单级通配符匹配。例如</p><p><em>myhome&#x2F;groundfloor&#x2F;+&#x2F;temperature</em> 就有下面这几种匹配方式。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt18.jpg" alt="jpg"></p><h3 id="多级通配符"><a href="#多级通配符" class="headerlink" title="多级通配符"></a>多级通配符</h3><p>多级通配符涵盖多个 Topic，<code>#</code> 代表 Topic 中的多级通配符。为了让 broker 能够确定和哪些 Topic 匹配，多级通配符必须作为 Topic 中的最后一个字符放置，并以 <code>/</code> 开头。</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt19.jpg" alt="jpg"></p><p>下面是 <em>myhome&#x2F;groundfloor&#x2F;#</em> 的几个例子</p><p><img src="/2022/03/23/MQTT%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/mqtt20.jpg" alt="jpg"></p><p>当 client 订阅带有多级通配符的 Topic 时，不论 Topic 有多长多深，它都会收到通配符之前 Topic 的所有消息。如果你只将 Topic 定义为 # 的话，那么你将会收到所有的消息。</p><h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p>作者：程序员cxuan</p><p>链接：<a href="https://juejin.cn/post/6976441705067184135">https://juejin.cn/post/6976441705067184135</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Channel 信道</title>
      <link href="/2022/03/22/GO-Channel-%E4%BF%A1%E9%81%93/"/>
      <url>/2022/03/22/GO-Channel-%E4%BF%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<p>说到channel，就一定要说一说线程了。任何实际项目，无论大小，并发是必然存在的。并发的存在，就涉及到线程通信。在当下的开发语言中，线程通讯主要有两种，共享内存与消息传递。共享内存一定都很熟悉，通过共同操作同一对象，实现线程间通讯。消息传递即通过类似聊天的方式。golang对并发的处理采用了协程的技术。golang的goroutine就是<strong>协程</strong>的实现。协程的概念很早就有，简单的理解为轻量级线程，goroutine就是为了解决并发任务间的通信而设计的。golang解决通信的理念是：不要通过共享内存来通信,而应该通过<strong>通信</strong>来共享内存。golang解决方案是消息传递机制，消息的传递就是通过channel来实现的。</p><p><strong>Channal是什么？</strong>Channal就是用来通信的，就像Unix下的管道一样，在Go中是这样使用Channel的。</p><p>下面的程序演示了一个goroutine和主程序通信的例程。这个程序足够简单了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    //创建一个string类型的channel</span><br><span class="line">    channel := make(chan string)</span><br><span class="line">    //创建一个goroutine向channel里发一个字符串</span><br><span class="line">    go func() &#123; channel &lt;- &quot;hello&quot; &#125;()</span><br><span class="line">    msg := &lt;- channel</span><br><span class="line">    fmt.Println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指定channel的buffer</strong></p><p>指定buffer的大小很简单，看下面的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    channel := make(chan string, 2)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        channel &lt;- &quot;hello&quot;</span><br><span class="line">        channel &lt;- &quot;World&quot;</span><br><span class="line">    &#125;()</span><br><span class="line">    msg1 := &lt;-channel</span><br><span class="line">    msg2 := &lt;-channel</span><br><span class="line">    fmt.Println(msg1, msg2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Channel的阻塞</strong></p><p>现在谈一谈对channe阻塞l的理解。　　</p><p>　　发送者角度：对于同一个通道，发送操作（协程或者函数中的），在<strong>接收者准备好之前是阻塞的</strong>。如果chan中的数据<strong>无人接收</strong>，就<strong>无法再给通道传入其他数据</strong>。因为新的输入无法在通道非空的情况下传入。所以发送操作会等待 chan 再次变为可用状态：就是通道值被接收时（可以传入变量）。</p><p>　　接收者角度：对于同一个通道，<strong>接收操作是阻塞的</strong>（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。</p><p><strong>案例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func f1(in chan int) &#123;</span><br><span class="line">    fmt.Println(&lt;-in)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    out := make(chan int)</span><br><span class="line">    out &lt;- 2   //13行</span><br><span class="line">    go f1(out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：fatal error: all goroutines are asleep - deadlock!</p><p>这是由于第13行之前不存在对out的接收，所以，对于out &lt;- 2来说，永远是阻塞的，即一直会等下去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这很明显，因为out&lt;-2插入后并没有被使用，就一直阻塞在等待被使用，走不到go fl(out)。所以将go fl(out)放在out&lt;-2前面即可。</span><br></pre></td></tr></table></figure><p><strong>案例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    c1 := make(chan int)</span><br><span class="line">    func()&#123;</span><br><span class="line">    time.Sleep(time.Second*2)</span><br><span class="line">    c1&lt;-&quot;result 1&quot;</span><br><span class="line">  &#125;()</span><br><span class="line">fmt.Println(&quot;c1 is&quot;,&lt;-c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：deadlock，因为push和pull永远不可能同时发生，这就是阻塞channel的不当用法。</p><p>解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    c1 := make(chan int)</span><br><span class="line">    go func()&#123;</span><br><span class="line">    time.Sleep(time.Second*2)</span><br><span class="line">    c1&lt;-&quot;result 1&quot;</span><br><span class="line">  &#125;()</span><br><span class="line">fmt.Println(&quot;c1 is&quot;,&lt;-c1)</span><br><span class="line">&#125;</span><br><span class="line">#通过在另一个协程中run push代码，使得channel的生产和消费可以同时对接，正常的阻塞使用方式。</span><br></pre></td></tr></table></figure><p>另外的解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    c1 := make(chan int,1)</span><br><span class="line">    func()&#123;</span><br><span class="line">    time.Sleep(time.Second*2)</span><br><span class="line">    c1&lt;-&quot;result 1&quot;</span><br><span class="line">  &#125;()</span><br><span class="line">fmt.Println(&quot;c1 is&quot;,&lt;-c1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 给channel加一个buffer，只要buffer没用尽，大家就不用阻塞。</span><br></pre></td></tr></table></figure><p><strong>案例3:</strong></p><p><strong>注意</strong>，channel默认上是阻塞的，也就是说，如果Channel满了，就阻塞写，如果Channel空了，就阻塞读。于是，我们就可以使用这种特性来同步我们的发送和接收端。</p><p>下面这个例程说明了这一点，代码有点乱，不过我觉得不难理解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;time&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    channel := make(chan string) </span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        channel &lt;- &quot;hello&quot; //发送方等待接收</span><br><span class="line">        fmt.Println(&quot;write \&quot;hello\&quot; done!&quot;)</span><br><span class="line"></span><br><span class="line">        channel &lt;- &quot;World&quot; //Reader在Sleep，这里在阻塞</span><br><span class="line">        fmt.Println(&quot;write \&quot;World\&quot; done!&quot;)</span><br><span class="line"></span><br><span class="line">        fmt.Println(&quot;Write go sleep...&quot;)</span><br><span class="line">        time.Sleep(3*time.Second)</span><br><span class="line">        channel &lt;- &quot;channel&quot;</span><br><span class="line">        fmt.Println(&quot;write \&quot;channel\&quot; done!&quot;)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(2*time.Second)</span><br><span class="line">    fmt.Println(&quot;Reader Wake up...&quot;) //首先打印</span><br><span class="line"></span><br><span class="line">    msg := &lt;-channel</span><br><span class="line">    fmt.Println(&quot;Reader: &quot;, msg)</span><br><span class="line"></span><br><span class="line">    msg = &lt;-channel</span><br><span class="line">    fmt.Println(&quot;Reader: &quot;, msg)</span><br><span class="line"></span><br><span class="line">    msg = &lt;-channel //Writer在Sleep，这里在阻塞</span><br><span class="line">    fmt.Println(&quot;Reader: &quot;, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Reader Wake up...</span><br><span class="line">Reader:  hello </span><br><span class="line">write &quot;hello&quot; done! </span><br><span class="line">write &quot;World&quot; done! </span><br><span class="line">Write go sleep...</span><br><span class="line">Reader:  World</span><br><span class="line">write &quot;channel&quot; done! </span><br><span class="line">Reader:  channel</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Reader Wake up...  //没有问题，不解释</span><br><span class="line"></span><br><span class="line">Reader:  hello</span><br><span class="line">因为go func()的代码在前，所以会先执行”channel &lt;- &quot;hello&quot;“，这时候被没有消费，阻塞。</span><br><span class="line">当主程序运行到msg := &lt;-channel，打印了Reader:  hello，然后执行到下面的msg = &lt;-channel，没有数据，被阻塞。</span><br><span class="line"></span><br><span class="line">write &quot;hello&quot; done! </span><br><span class="line">write &quot;World&quot; done! </span><br><span class="line">Write go sleep...</span><br><span class="line">go func()执行channel&lt;-&quot;hello&quot;阻塞被释放，执行代码fmt.Println(&quot;write \&quot;hello\&quot; done!&quot;)；</span><br><span class="line">然后执行channel &lt;- &quot;World&quot;的时候，插入数据，因为主程序已有读取请求，所以没有阻塞，并打印write &quot;World&quot; done!和Write go sleep...; 然后，channel &lt;- &quot;channel&quot;因为需要等待3s未马上执行到，所以会比主程序慢。</span><br><span class="line"></span><br><span class="line">Reader:  World</span><br><span class="line">主程序里面msg = &lt;-channel因channel &lt;- &quot;World&quot;，有数据了，解除阻塞打印Reader:  World，并再执行下面代码msg = &lt;-channel，这时候因为channel &lt;- &quot;channel&quot;还在等待中，再次被阻塞。</span><br><span class="line"></span><br><span class="line">write &quot;channel&quot; done!</span><br><span class="line">直到3s后，channel &lt;- &quot;channel&quot;解除阻塞，打印write &quot;channel&quot; done!</span><br><span class="line"></span><br><span class="line">Reader:  channel</span><br><span class="line">主程序解除阻塞，再打印Reader:  channel</span><br></pre></td></tr></table></figure><p><strong>详解go语言 make(chan int, 1) 和 make (chan int) 的区别</strong></p><p><strong>无缓冲区channel</strong></p><p>用make(chan int) 创建的chan, 是无缓冲区的, send 数据到chan 时，在没有协程取出数据的情况下， 会阻塞当前协程的运行。ch &lt;- 后面的代码就不会再运行，直到channel 的数据被接收，当前协程才会继续往下执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int) // 创建无缓冲channel</span><br><span class="line">    go func() &#123;</span><br><span class="line">      fmt.Println(&quot;time sleep 5 second...&quot;)</span><br><span class="line">      time.Sleep(5 * time.Second)</span><br><span class="line">      &lt;-ch</span><br><span class="line">      fmt.Println(&quot;read...&quot;)</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(&quot;即将阻塞...&quot;)</span><br><span class="line">    ch &lt;-1  // 协程将会阻塞，等待数据被读取</span><br><span class="line">    fmt.Println(&quot;ch 数据被消费，主协程退出&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#结果：</span><br><span class="line">即将阻塞...</span><br><span class="line">time sleep 5 second...</span><br><span class="line">send...</span><br><span class="line">ch 数据被消费，主协程退出</span><br><span class="line"></span><br><span class="line">##这边可以看到接收方的代码先打印，然后打印发送方下面的代码，这个符合逻辑，接收解锁执行，发送解锁执行。</span><br></pre></td></tr></table></figure><p><strong>有缓冲区channel</strong></p><p>channel 的缓冲区为1，向channel 发送第一个数据，主协程不会退出。发送第二个时候，缓冲区已经满了， 此时阻塞主协程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">      ch := make(chan int, 1) // 创建有缓冲channel</span><br><span class="line">      go func() &#123;</span><br><span class="line">         fmt.Println(&quot;time sleep 5 second...&quot;)</span><br><span class="line">         time.Sleep(5 * time.Second)</span><br><span class="line">         &lt;-ch</span><br><span class="line">         fmt.Println(&quot;read...&quot;)</span><br><span class="line">      &#125;()</span><br><span class="line">      ch &lt;-1 // 协程不会阻塞，等待数据被读取</span><br><span class="line">      fmt.Println(&quot;第二次发送数据到channel， 即将阻塞&quot;)</span><br><span class="line">      ch &lt;-1 // 第二次发送数据到channel, 在数据没有被读取之前，因为缓冲区满了， 所以会阻塞主协程。</span><br><span class="line">      fmt.Println(&quot;ch 数据被消费，主协程退出&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">第二次发送数据到channel， 即将阻塞   //阻塞了，因为buffer为1，等待前面的消费</span><br><span class="line">time sleep 5 second...</span><br><span class="line">read...               //消费了</span><br><span class="line">ch 数据被消费，主协程退出 //插入，执行</span><br></pre></td></tr></table></figure><p><strong>多个Channel的select</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;time&quot;</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    //创建两个channel - c1 c2</span><br><span class="line">    c1 := make(chan string)</span><br><span class="line">    c2 := make(chan string)</span><br><span class="line">    //创建两个goruntine来分别向这两个channel发送数据</span><br><span class="line">    go func() &#123;</span><br><span class="line">        time.Sleep(time.Second * 1)</span><br><span class="line">        c1 &lt;- &quot;Hello&quot;</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        time.Sleep(time.Second * 1)</span><br><span class="line">        c2 &lt;- &quot;World&quot;</span><br><span class="line">    &#125;()</span><br><span class="line">    //使用select来侦听两个channel</span><br><span class="line">    for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">          case msg1 := &lt;-c1:</span><br><span class="line">              fmt.Println(&quot;received&quot;, msg1)</span><br><span class="line">          case msg2 := &lt;-c2:</span><br><span class="line">              fmt.Println(&quot;received&quot;, msg2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面的select是阻塞的，所以，才搞出ugly的for i &lt;2这种东西。</p><p><strong>Channel select阻塞的Timeout</strong></p><p>解决上述那个for循环的问题，一般有两种方法：一种是阻塞但有timeout，一种是无阻塞。我们来看看如果给select设置上timeout的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    timeout_cnt := 0</span><br><span class="line">    select &#123;</span><br><span class="line">    case msg1 := &lt;-c1:</span><br><span class="line">        fmt.Println(&quot;msg1 received&quot;, msg1)</span><br><span class="line">    case msg2 := &lt;-c2:</span><br><span class="line">        fmt.Println(&quot;msg2 received&quot;, msg2)</span><br><span class="line">    case  &lt;-time.After(time.Second * 30)：</span><br><span class="line">        fmt.Println(&quot;Time Out&quot;)</span><br><span class="line">        time_cnt++</span><br><span class="line">    &#125;</span><br><span class="line">    if time_cnt &gt; 1 &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中高亮的代码主要是用来让select返回的，注意 case中的time.After事件。</p><p><strong>Channel的无阻塞</strong></p><p>好，我们再来看看无阻塞的channel，其实也很简单，就是在select中加入default，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case msg1 := &lt;-c1:</span><br><span class="line">        fmt.Println(&quot;received&quot;, msg1)</span><br><span class="line">    case msg2 := &lt;-c2:</span><br><span class="line">        fmt.Println(&quot;received&quot;, msg2)</span><br><span class="line">    default: //default会导致无阻塞</span><br><span class="line">        fmt.Println(&quot;nothing received!&quot;)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Channel的关闭</strong></p><p>关闭Channel可以通知对方内容发送完了，不用再等了。参看下面的例程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;time&quot;</span><br><span class="line">import &quot;math/rand&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    channel := make(chan string)</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    //向channel发送随机个数的message</span><br><span class="line">    go func () &#123;</span><br><span class="line">        cnt := rand.Intn(10)</span><br><span class="line">        fmt.Println(&quot;message cnt :&quot;, cnt)</span><br><span class="line">        for i:=0; i&lt;cnt; i++&#123;</span><br><span class="line">            channel &lt;- fmt.Sprintf(&quot;message-%2d&quot;, i)</span><br><span class="line">        &#125;</span><br><span class="line">        close(channel) //关闭Channel</span><br><span class="line">    &#125;()</span><br><span class="line">    var more bool = true</span><br><span class="line">    var msg string</span><br><span class="line">    for more &#123;</span><br><span class="line">        select&#123;</span><br><span class="line">        //channel会返回两个值，一个是内容，一个是还有没有内容</span><br><span class="line">        case msg, more = &lt;- channel:</span><br><span class="line">            if more &#123;</span><br><span class="line">                fmt.Println(msg)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                fmt.Println(&quot;channel closed!&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://www.cnblogs.com/xiaofengshuyu/p/5190824.html">golang协程——通道channel阻塞</a></p><p><a href="https://zhuanlan.zhihu.com/p/22620172">golang channel阻塞与非阻塞用法</a></p><p><a href="https://blog.csdn.net/qq_31406415/article/details/110521553">详解go语言 make(chan int, 1) 和 make (chan int) 的区别</a></p><p><a href="https://coolshell.cn/articles/8489.html#goroutine">GO 语言简介（下）— 特性</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GO入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins</title>
      <link href="/2022/03/21/Jenkins/"/>
      <url>/2022/03/21/Jenkins/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/mPkhy7YvrYO_HnfL-rho3w">超级详细！开发集成工具Jenkins使用教程</a></p><p><a href="https://juejin.cn/post/7064389514470359053">docker | jenkins 自动化CI&#x2F;CD，后端躺着把运维的钱挣了！(下)</a></p><p><code>docker + jenkins:</code>使用jenkins监听git仓库的变化，一旦发生变化就<strong>自动拉取git仓库代码，构建docker镜像，然后自动部署，运行容器</strong>。只要push了代码，则新一版的项目就会由jenkins自动部署到指定服务器。</p><p><code>账号:浅蝶果果 密码:qqx</code></p><blockquote><p>创建仓库</p></blockquote><p>访问<code>https://hub.docker.com/</code></p><p>点击<code>菜单栏 Repositories</code>  -&gt; <code>Create Repository</code></p><blockquote><p>安装Jenkins</p></blockquote><p><a href="https://www.jenkins.io/zh/doc/tutorials/build-a-python-app-with-pyinstaller/">官方连接</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -d \</span><br><span class="line">  --rm \</span><br><span class="line">  -u root \</span><br><span class="line">  -p 9026:8080 \</span><br><span class="line">  -v jenkins-data:/var/jenkins_home \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  -v &quot;$HOME&quot;:/home \</span><br><span class="line">  jenkinsci/blueocean</span><br></pre></td></tr></table></figure><p>因为我8080已应用别的内容，就修改成9026。</p><p>请求：localhost:8080，会跳转到页面让你填写初始密码</p><p><strong>获取初始密码</strong></p><p>进入<code>docker exec -it a3c5c0caecfb  bash</code></p><p><code>cat /var/jenkins_home/secrets/initialAdminPassword</code>  &#x2F;&#x2F;这个页面会有提示地址的</p><p><code>b950574b0c2c43b78e03ee0a8a2aecc3</code></p><p><strong>选择推荐安装</strong></p><p><strong>创建第一个管理员用户</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">king</span><br><span class="line">123456aa</span><br><span class="line">123456aa</span><br><span class="line">王</span><br><span class="line">2496978350@qq.com</span><br></pre></td></tr></table></figure><p><strong>保存，然后进入后台咯</strong></p><h2 id="Docker创建私有仓库-学习"><a href="#Docker创建私有仓库-学习" class="headerlink" title="Docker创建私有仓库(学习)"></a>Docker创建私有仓库(学习)</h2><p><a href="https://www.cnblogs.com/huangenai/p/10012672.html">docker for mac 创建私有仓库</a></p><p><a href="https://blog.csdn.net/weixin_33724659/article/details/93810200">Mac 环境部署Docker私有仓库</a></p><p>拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure><p>运行registry</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /Users/huangyanyu/WWW/docker/registry:/var/lib/registry registry</span><br></pre></td></tr></table></figure><ul><li><strong>-i</strong>: 交互式操作。</li><li><strong>-t</strong>: 终端。</li><li><strong>-v:</strong> 将宿主机目录挂载到容器里, 或者说把镜像路径映射到本机。<code>-v /宿主机目录:/容器目录</code></li><li><strong>-d</strong> 指定容器的运行模式，后台运行，默认不会进入容器</li></ul><ul><li><strong>-P (大写):<strong>是容器内部端口</strong>随机</strong>映射到主机的端口。</li><li><strong>-p(小写) :</strong> 是<strong>容器内部端口</strong>绑定到<strong>指定</strong>的<strong>主机端口</strong>。-p <strong>指定</strong>的<strong>主机端口</strong>  <strong>容器内部端口</strong></li><li><strong>docker attach</strong></li><li><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</li></ul><p><code>fe1a0525e19102c5208ab141cc96dfebe51f5445dc71c2ee181d32fd05995f36</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看运行容器</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">//进入容器  fe1a0525e191是容器id 在上一步骤中获得 </span><br><span class="line">sudo docker attach fe1a0525e191 （失败）</span><br><span class="line">sudo docker exec -it fe1a0525e191 /bin/bash (失败)</span><br></pre></td></tr></table></figure><p>本地仓库非安全配置 user&#x2F;<username>&#x2F;.docker&#x2F;daemon.json</username></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat .docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">  &quot;insecure-registries&quot; : [</span><br><span class="line">    &quot;127.0.0.1:5000&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;debug&quot; : true,</span><br><span class="line">  &quot;experimental&quot; : true,</span><br><span class="line">  &quot;registry-mirrors&quot; : [</span><br><span class="line">    &quot;https://8q2dp9p9.mirror.aliyuncs.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看仓库中的镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://127.0.0.1:5000/v2/_catalog</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper实战之服务注册与发现</title>
      <link href="/2022/03/21/zookeeper%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
      <url>/2022/03/21/zookeeper%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>在这一篇之前，建议先阅读<a href="zookeeper%E9%80%89%E4%B8%BE%E5%92%8C%E5%90%8C%E6%AD%A5.md">zookeeper选举和同步.md</a>,阅读清楚后，可以接着轻阅读<a href="https://www.cnblogs.com/raphael5200/p/5285583.html">Zookeeper工作原理（详细）</a>,然后开始本篇章。</p><p>参考文章：</p><p><a href="https://segmentfault.com/a/1190000019670015">zookeeper实战之服务注册与发现</a></p><p><a href="https://www.jianshu.com/p/bfd7e2f8e1a7">Zookeeper-服务注册与发现</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper安装</title>
      <link href="/2022/03/21/zookeeper%E5%AE%89%E8%A3%85/"/>
      <url>/2022/03/21/zookeeper%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://blog.51cto.com/nileader/795230"><strong>【ZooKeeper Notes 2】ZooKeeper快速搭建</strong></a></p><p><a href="https://blog.csdn.net/jiangxiulilinux/article/details/96433560"><strong>zookeeper-3.5.5安装报错：找不到或无法加载主类 org.apache.zookeeper.server.quorum.QuorumPeerMain-新版本zookeeper易犯错误</strong></a></p><h4 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h4><ol><li>安装jdk</li><li>地址：<code>https://mirror.bjtu.edu.cn/reverse/apache-archive/zookeeper/zookeeper-3.7.0/</code></li><li>拉取<code>wget https://mirror.bjtu.edu.cn/reverse/apache-archive/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz --no-check-certificate</code></li><li>解压 <code>tar -zxvf apache-zookeeper-3.7.0-bin.tar.gz</code></li><li>修改名称<code>mv apache-zookeeper-3.7.0-bin zookeeper-3.7.0 </code></li><li>移动到你想的位置 <code>mv zookeeper-3.7.0/ /usr/local/</code></li><li>复制 <code>cp /usr/local/zookeeper-3.7.0/conf/zoo_sample.cfg  /usr/local/zookeeper-3.7.0/conf/zoo.cfg</code></li><li>vi zoo.cfg，修改 <code>dataDir=/usr/local/zookeeper-3.7.0/data</code></li><li>创建数据目录：<code>mkdir /usr/local/zookeeper-3.7.0/data</code></li><li>启动zookeeper：<code>/usr/local/zookeeper-3.7.0/bin/zkServer.sh start</code></li><li>检测是否成功启动:<code>/usr/local/zookeeper-3.7.0/bin/zkCli.sh</code> 或<code>echo stat|nc localhost 2181</code></li><li>记得要开启2181端口,以及修改zoo.cfg   <code>admin.serverPort=9051</code>,因为默认会用8080，可以会占用，导致启动却无进程。</li><li>查看进程<code>ps -ef | grep zookeeper</code></li></ol><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><strong>zoo.cfg</strong> 五大基础参数配置，其中 <code>tickTime</code> 就是基础时间。 <code>initLimit</code> 就是初始化的最大值， <code>syncLimit</code> 就是 异步交互的最大值。 <code>dataDir</code> 就是保存数据和快照的目录， <code>clientPort</code> 就是端口</p><p>通过 <code>bin/zkCli.sh -server 127.0.0.1:2181</code> 可以连接这台zk的 cli 服务。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 1] ls /</span><br><span class="line">[gopush-cluster-message, gopush-cluster-comet, zookeeper]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper选举</title>
      <link href="/2022/03/21/zookeeper%E9%80%89%E4%B8%BE%E5%92%8C%E5%90%8C%E6%AD%A5/"/>
      <url>/2022/03/21/zookeeper%E9%80%89%E4%B8%BE%E5%92%8C%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Zookeeper 是一个分布式服务框架，主要是用来解决分布式应用中遇到的一些数据管理问题如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p><p>很多分布式中间件都利用zk来提供分布式一致性协调的特性。dubbo官方推荐使用zk作为注册中心，zk也是hadoop和Hbase的重要组件。其他知名的开源中间件中也都出现了zk的身影。</p><h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><p><strong>注意如果 Zookeeper 是单机部署是不需要选举的，集群模式下才需要选举。</strong></p><blockquote><p> 选举四步骤：</p></blockquote><ul><li>个人能力</li></ul><p>如何衡量 Zookeeper 节点个人能力？答案是靠<strong>数据是否够新</strong>，如果节点的<strong>数据越新</strong>就代表这个节点的个人能力<strong>越强</strong>，是不是感觉很奇怪，就是这么定的！</p><p>在 Zookeeper 中通常是以事务id（后面简称zxid）来标识数据的新旧程度（版本），节点最新的zxid越大代表这个节点的数据越新，也就代表这个节点能力越强。</p><p>zxid 的全称是 ZooKeeper Transaction Id，即 Zookeeper 事务id。</p><ul><li>遇强改投</li></ul><p>在集群选举开始时，节点首先认为自己是最强的（即数据是最新的），然后在选票上写上自己的名字（包括zxid和sid），zxid 是事务id，sid 唯一标识自己。</p><p>紧接着会将选票传递给其他节点，同时自己也会接收其他节点传过来的选票。每个节点接收到选票后会做比较，这个人是不是比我强（zxid比我大），如果比较强，那我就需要改票，明明别人比我强，我也不能厚着脸皮对吧。</p><ul><li>投票箱</li></ul><p>与人类选举投票箱稍微有点不一样，Zookeeper 集群会在每个节点的内存中维护一个投票箱。节点会将自己的选票以及其他节点的选票都放在这个投票箱中。由于选票是互相传阅的，所以最终每个节点投票箱中的选票会是一样的。</p><ul><li>领导者</li></ul><p>在投票的过程中会去统计是否有<strong>超过一半</strong>的选票选择同一个节点。一旦集群中有超过半数的节点都认为某个节点最强，那该节点就是领导者了，投票也宣告结束。</p><blockquote><p><strong>什么场景下 Zookeeper 需要选举？</strong></p></blockquote><p>当 Zookeeper 集群中的一台服务器出现以下两种情况之一时，需要进入 Leader 选举。</p><p>（1）服务器初始化启动。</p><p>（2）服务器运行期间 Leader 故障。</p><blockquote><p>启动时期的 Leader 选举</p></blockquote><p>假设一个 Zookeeper 集群中有5台服务器，id从1到5编号，并且它们都是最新启动的，没有历史数据。</p><p><img src="/2022/03/21/zookeeper%E9%80%89%E4%B8%BE%E5%92%8C%E5%90%8C%E6%AD%A5/zk1.png"></p><p>集群刚启动选举过程</p><p>假设服务器依次启动，我们来分析一下选举过程：</p><p>（1）服务器1启动</p><p>发起一次选举，服务器1投自己一票，此时服务器1票数一票，不够半数以上（3票），选举无法完成。</p><p>投票结果：服务器1为1票。</p><p>服务器1状态保持为LOOKING。</p><p>（2）服务器2启动</p><p>发起一次选举，服务器1和2分别投自己一票，此时服务器1发现服务器2的id比自己大，更改选票投给服务器2。</p><p>投票结果：服务器1为0票，服务器2为2票。</p><p>服务器1，2状态保持LOOKING</p><p>（3）服务器3启动</p><p>发起一次选举，服务器1、2、3先投自己一票，然后因为服务器3的id最大，两者更改选票投给为服务器3；</p><p>投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数（3票），服务器3当选Leader。</p><p>服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING。</p><p>（4）服务器4启动</p><p>发起一次选举，此时服务器1，2，3已经不是LOOKING 状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3。</p><p>服务器4并更改状态为FOLLOWING。</p><p>（5）服务器5启动</p><p>与服务器4一样投票给3，此时服务器3一共5票，服务器5为0票。服务器5并更改状态为FOLLOWING。</p><p>最终的结果：</p><p>服务器3是 Leader，状态为 LEADING；其余服务器是 Follower，状态为 FOLLOWING。</p><blockquote><p>运行时期的Leader选举</p></blockquote><p>在Zookeeper运行期间 Leader 和 非 Leader 各司其职，当有非 Leader 服务器宕机或加入不会影响 Leader，但是一旦 Leader 服务器挂了，那么整个 Zookeeper 集群将暂停对外服务，会触发新一轮的选举。</p><p>初始状态下服务器3当选为Leader，假设现在服务器3故障宕机了，此时每个服务器上zxid可能都不一样，server1为99，server2为102，server4为100，server5为101</p><p><img src="/2022/03/21/zookeeper%E9%80%89%E4%B8%BE%E5%92%8C%E5%90%8C%E6%AD%A5/zk2.png"></p><p>集群 Leader 节点故障运行期选举与初始状态投票过程基本类似，大致可以分为以下几个步骤：</p><p>（1）状态变更。Leader 故障后，余下的非 Observer 服务器都会将自己的服务器状态变更为LOOKING，然后开始进入Leader选举过程。</p><p>（2）每个Server会发出投票。</p><p>（3）接收来自各个服务器的投票，如果其他服务器的数据比自己的新会改投票。</p><p>（4）处理和统计投票，每一轮投票结束后都会统计投票，超过半数即可当选。</p><p>（5）改变服务器的状态，宣布当选。</p><p><img src="/2022/03/21/zookeeper%E9%80%89%E4%B8%BE%E5%92%8C%E5%90%8C%E6%AD%A5/zk3.png"></p><p>运行器 Leader 故障后选举流程</p><p>（1）第一次投票，每台机器都会将票投给自己。</p><p>（2）接着每台机器都会将自己的投票发给其他机器，如果发现其他机器的zxid比自己大，那么就需要改投票重新投一次。比如server1 收到了三张票，发现server2的xzid为102，pk一下发现自己输了，后面果断改投票选server2为老大。</p><blockquote><p>选举机制中涉及到的核心概念</p></blockquote><p>敲黑板了，这些概念是面试必考的。</p><p>（1）Server id（或sid）：服务器ID</p><p>比如有三台服务器，编号分别是1,2,3。编号越大在选择算法中的权重越大，比如初始化启动时就是根据服务器ID进行比较。</p><p>（2）Zxid：事务ID</p><p>服务器中存放的数据的事务ID，值越大说明数据越新，在选举算法中数据越新权重越大。</p><p>（3）Epoch：逻辑时钟</p><p>也叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的，每投完一次票这个数据就会增加。</p><p>（4）Server状态：选举状态</p><p>LOOKING，竞选状态。</p><p>FOLLOWING，随从状态，同步leader状态，参与投票。</p><p>OBSERVING，观察状态,同步leader状态，不参与投票。</p><p>LEADING，领导者状态。</p><blockquote><p>总结</p></blockquote><p>（1）Zookeeper 选举会发生在服务器初始状态和运行状态下。</p><p>（2）初始状态下会根据服务器sid的编号对比，编号越大权值越大，投票过半数即可选出Leader。</p><p>（3）Leader 故障会触发新一轮选举，zxid 代表数据越新，权值也就越大。</p><p>（4）在运行期选举还可能会遇到脑裂的情况，大家可以自行学习。</p><h2 id="具体可以看下面原文章"><a href="#具体可以看下面原文章" class="headerlink" title="具体可以看下面原文章:"></a>具体可以看下面原文章:</h2><p><a href="https://baijiahao.baidu.com/s?id=1685254558927619982&wfr=spider&for=pc"><strong>用大白话给你解释Zookeeper的选举机制</strong></a></p><h2 id="Zookeeper的同步机制"><a href="#Zookeeper的同步机制" class="headerlink" title="Zookeeper的同步机制"></a>Zookeeper的同步机制</h2><p>zookeeper的数据同步是为了保证每个节点的数据一致性，大致分为2个流程，一个是正常的客户端数据提交流程，二是集群中某个节点宕机后数据恢复流程。</p><blockquote><p>正常客户端数据提交流程</p></blockquote><p>客户端写入数据提交流程大致为：leader接受到客户端的写请求，然后同步给各个子节点：</p><p><img src="/2022/03/21/zookeeper%E9%80%89%E4%B8%BE%E5%92%8C%E5%90%8C%E6%AD%A5/zk4.png"></p><p>但是有童鞋就产生疑惑了，客户端一般连接的是所有节点，客户端并不知道哪个是leader呀。</p><p>的确，客户端会和所有的节点建立链接，并且发起写入请求是挨个遍历节点进行的，比如第一次是节点1，第二次是节点2。以此类推。</p><p>如果客户端正好链接的节点的角色是leader，那就按照上面的流程走。那如果链接的节点不是leader，是follower呢，则有以下流程：</p><p><img src="/2022/03/21/zookeeper%E9%80%89%E4%B8%BE%E5%92%8C%E5%90%8C%E6%AD%A5/zk5.png"></p><p>如果Client选择链接的节点是Follower的话，这个Follower会把请求转给当前Leader，然后Leader会走蓝色的线把请求广播给所有的Follower，每个节点同步完数据后会走绿色的线告诉Leader数据已经同步完成（但是还未提交），当Leader收到半数以上的节点ACK确认消息后，那么Leader就认为这个数据可以提交了，会广播给所有的Follower节点，所有的节点就可以提交数据。整个同步工作就结束了。</p><blockquote><p>那我们再来说说节点宕机后的数据同步流程</p></blockquote><p>当zookeeper集群中的Leader宕机后，会触发新的选举，选举期间，整个集群是没法对外提供服务的。直到选出新的Leader之后，才能重新提供服务。</p><p>我们重新回到3个节点的例子，zk1，zk2，zk3，其中zk2为Leader，zk1，zk3为Follower，假设zk2宕机后，触发了重新选举，假设zk3的数据更新即ZXID更大，按照选举规则，zk3当选Leader。这时整个集群只整下zk1和zk3，如果这时整个集群又创建了一个节点数据，接着zk2重启。这时zk2的数据肯定比z1和z3要旧，那这时该如何同步数据呢。</p><p>zookeeper是通过ZXID事务ID来确认的，ZXID是一个长度为64位的数字，其中低32位是按照数字来递增，任何数据的变更都会导致低32位数字简单加1。高32位是leader周期编号，每当选举出一个新的Leader时，新的Leader就从本地事务日志中取出ZXID，然后解析出高32位的周期编号，进行加1，再将低32位的全部设置为0。这样就保证了每次选举新的Leader后，保证了ZXID的唯一性而且是保证递增的。</p><p>如果Leader宕机之后，再重启后，会去和目前的Leader去比较最新的ZXID，如果节点的ZXID比最新Leader里的ZXID要小，那么就会去同步数据。</p><p>再提及一下选举问题，zk的选举过程会优先考虑ZXID大的节点，这时如果zk1和zk3的ZXID一样大，选举只会在这2个节点中产生，根据之前说的选举规则。在第一轮投票的时候，zk1只要获得1票，就能达到半数了，就能顺利当选为Leader了。</p><h2 id="具体可以看下面原文章-1"><a href="#具体可以看下面原文章-1" class="headerlink" title="具体可以看下面原文章:"></a>具体可以看下面原文章:</h2><p><a href="https://www.cnblogs.com/bryan31/p/15378629.html">Zookeeper的选举机制和同步机制超详细讲解，面试经常问到！</a></p><p>附：<a href="http://www.pangxieke.com/share/use-docker-and-nginx-implement-load-balancing-on-one-service.html">Nginx+Docker在一台服务器上模拟实现负载均衡</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICE协议下NAT穿越的实现（STUN&amp;TURN）</title>
      <link href="/2022/03/20/ICE%E5%8D%8F%E8%AE%AE%E4%B8%8BNAT%E7%A9%BF%E8%B6%8A%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88STUN-TURN%EF%BC%89/"/>
      <url>/2022/03/20/ICE%E5%8D%8F%E8%AE%AE%E4%B8%8BNAT%E7%A9%BF%E8%B6%8A%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88STUN-TURN%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这一篇感觉写得真好。</p><p>NAT是什么？看上一篇《P2P通信原理与实现》</p><blockquote><p>NAT的副作用以及解决方案</p></blockquote><p>国内移动无线网络运营商在链路上一段时间内没有数据通讯后, 会淘汰NAT表中的对应项, 造成链路中断。</p><h5 id="这是NAT带来的第一个副作用：NAT超时"><a href="#这是NAT带来的第一个副作用：NAT超时" class="headerlink" title="这是NAT带来的第一个副作用：NAT超时:"></a>这是NAT带来的第一个副作用：NAT超时:</h5><p>而国内的运营商一般NAT超时的时间为5分钟，所以通常我们TCP长连接的心跳设置的时间间隔为3-5分钟。</p><h5 id="而第二个副作用就是：我们这边文章要提到的NAT墙。"><a href="#而第二个副作用就是：我们这边文章要提到的NAT墙。" class="headerlink" title="而第二个副作用就是：我们这边文章要提到的NAT墙。"></a>而第二个副作用就是：我们这边文章要提到的NAT墙。</h5><p>NAT会有一个机制，所有外界对内网的请求，到达NAT的时候，都会被NAT所丢弃，这样如果我们处于一个NAT设备后面，我们将无法得到任何外界的数据。</p><p>但是这种机制有一个解决方案：就是如果我们A主动往B发送一条信息，这样A就在自己的NAT上打了一个B的洞。这样A的这条消息到达B的NAT的时候，虽然被丢掉了，但是如果B这个时候在给A发信息，到达A的NAT的时候，就可以从A之前打的那个洞中，发送给到A手上了。</p><p>简单来讲，就是<strong>如果A和B要进行通信，那么得事先A发一条信息给B，B发一条信息给A。这样提前在各自的NAT上打了对方的洞，这样下一次A和B之间就可以进行通信了。</strong></p><blockquote><p> 四种NAT类型，看上一篇《P2P通信原理与实现》后就完全能理解下面这段话了。</p></blockquote><p>RFC3489 中将 NAT 的实现分为四大类：</p><ol><li>Full Cone NAT                          （完全锥形 NAT）</li><li>Restricted Cone NAT                 （限制锥形 NAT ，可以理解为 IP 限制，Port不限制）</li><li>Port Restricted Cone NAT          （端口限制锥形 NAT，IP+Port 限制）</li><li>Symmetric NAT                        （对称 NAT）</li></ol><p>其中完全最上层的完全锥形NAT的穿透性最好，而最下层的对称形NAT的安全性最高。</p><p>简单来讲讲这4种类型的NAT代表什么：</p><ul><li>如果一个NAT是Full Cone NAT，那么无论什么IP地址访问，都不会被NAT墙掉（这种基本很少）。</li><li>Restricted Cone NAT，仅仅是经过打洞的IP能穿越NAT，但是不限于Port。</li><li>Port Restricted Cone NAT，仅仅是经过打洞的IP+端口号能穿越NAT。</li><li>Symmetric NAT 这种也是仅仅是经过打洞的IP+端口号能穿越NAT，但是它有一个最大的和Cone类型的NAT的区别，它对外的公网Port是不停的变化的：<br>比如A是一个对称NAT，那么A给B发信息，经过NAT映射到一个Port:10000，A给C发信息，经过NAT映射到一个Port:10001，这样会导致一个问题，我们服务器根本无法协调进行NAT打洞。</li></ul><p>至于为什么无法协调打洞，下面我们会从STUN和TURN的工作原理来讲。</p><blockquote><h4 id="STUN和TURN的实现"><a href="#STUN和TURN的实现" class="headerlink" title="STUN和TURN的实现"></a>STUN和TURN的实现</h4></blockquote><h5 id="1-STUN-Server主要做了两件事："><a href="#1-STUN-Server主要做了两件事：" class="headerlink" title="1.STUN Server主要做了两件事："></a>1.STUN Server主要做了两件事：</h5><ul><li>接受客户端的请求，并且把客户端的公网IP、Port封装到ICE Candidate中。</li></ul><ul><li>通过一个复杂的机制，<strong>得到客户端的NAT类型</strong>。</li></ul><p>完成了这些STUN Server就会这些基本信息发送回客户端，然后根据NAT类型，来判断是否需要TURN服务器协调进行下一步工作。</p><p>我们来讲讲这两步具体做了什么吧：<br>第一件事就不用说了，其实就是得到客户端的请求，把源IP和Port拿到，添加到ICE Candidate中。</p><h6 id="来讲讲第二件事，STUN是如何判断NAT的类型的："><a href="#来讲讲第二件事，STUN是如何判断NAT的类型的：" class="headerlink" title="来讲讲第二件事，STUN是如何判断NAT的类型的："></a>来讲讲第二件事，STUN是如何判断NAT的类型的：</h6><p>假设B是客户端，C是STUN服务器，C有两个IP分别为IP1和IP2（至于为什么要两个IP，接着往下看）：</p><h6 id="STEP1-判断客户端是否在NAT后："><a href="#STEP1-判断客户端是否在NAT后：" class="headerlink" title="STEP1.判断客户端是否在NAT后："></a>STEP1.判断客户端是否在NAT后：</h6><p>B向C的<strong>IP1的port1端口</strong>发送一个UDP 包。C收到这个包后，会把它收到包的<strong>源</strong>IP和port写到UDP包中，然后把此包通过IP1和port1发还给B。</p><p>这边还给B包中的IP和port也就是B的NAT的外网 IP和port，也就是说你在STEP1中就得到了B的NAT的外网IP。</p><p>熟悉NAT工作原理的朋友可以知道，C返回给B的这个UDP包B一定收到**(因为由B主动先发送给C，B的NAT已经记录下了C的IP和端口)**。如果在你的应用中，向一个STUN服务器发送数据包后，你没有收到STUN的任何回应包，那只有两种可能：1、STUN服务器不存在，或者你弄错了port。2、你的NAT拒绝一切UDP包从外部向内部通过。</p><p>当B收到此UDP后，把此UDP中的IP和自己的IP做比较，如果是一样的，就说明自己是在<strong>公网</strong>，下步NAT将去探测防火墙类型，这边不做介绍。如果不一样，说明有NAT的存在，系统进行STEP2的操作。</p><h6 id="STEP2-判断是否处于Full-Cone-Nat下："><a href="#STEP2-判断是否处于Full-Cone-Nat下：" class="headerlink" title="STEP2.判断是否处于Full Cone Nat下："></a>STEP2.判断是否处于Full Cone Nat下：</h6><p>B向C的IP1发送一个UDP包，请求C通过另外一个IP2和PORT（不同与SETP1的IP1）向B返回一个UDP数据包（现在知道为什么C要有两个IP了吧，虽然还不理解为什么，呵呵）。</p><p>我们来分析一下，如果B收到了这个数据包，那说明什么？说明NAT来着不拒，不对数据包进行任何过滤，这也就是STUN标准中的full cone NAT。遗憾的是，Full Cone Nat太少了，这也意味着你能收到这个数据包的可能性不大。如果没收到，那么系统进行STEP3的操作。</p><h6 id="STEP3-判断是否处于对称NAT下："><a href="#STEP3-判断是否处于对称NAT下：" class="headerlink" title="STEP3.判断是否处于对称NAT下："></a>STEP3.判断是否处于对称NAT下：</h6><p>B向C的IP2的port2发送一个数据包，C收到数据包后，把它收到包的源IP和port写到UDP包中，然后通过自己的IP2和port2把此包发还给B。</p><p>和step1一样，B肯定能收到这个回应UDP包。此包中的port是我们最关心的数据，下面我们来分析：<br>如果这个port和step1中的port一样，那么可以肯定这个NAT是个CONE NAT，否则是对称NAT。道理很简单：根据对称NAT的规则，当目的地址的IP和port有任何一个改变，那么NAT都会重新分配一个port使用，而在step3中，和step1对应，我们改变了IP和port。因此，如果是对称NAT,那这两个port肯定是不同的。</p><p>如果在你的应用中，到此步的时候PORT是不同的，那么这个它就是处在一个对称NAT下了。如果相同，那么只剩下了restrict cone 和port restrict cone。系统用step4探测是是那一种。</p><h6 id="STEP4-判断是处于Restrict-Cone-NAT还是Port-Restrict-NAT之下："><a href="#STEP4-判断是处于Restrict-Cone-NAT还是Port-Restrict-NAT之下：" class="headerlink" title="STEP4.判断是处于Restrict Cone NAT还是Port Restrict NAT之下："></a>STEP4.判断是处于Restrict Cone NAT还是Port Restrict NAT之下：</h6><p>B向C的IP2的一个端口PD发送一个数据请求包，要求C用IP2和不同于PD的port返回一个数据包给B。</p><p>我们来分析结果：如果B收到了，那也就意味着只要IP相同，即使port不同，NAT也允许UDP包通过。显然这是Restrict Cone NAT。如果没收到，没别的好说，Port Restrict NAT.</p><h6 id="到这里STUN-Server一共通过这4步，判断出客户端处于什么类型的NAT下，"><a href="#到这里STUN-Server一共通过这4步，判断出客户端处于什么类型的NAT下，" class="headerlink" title="到这里STUN Server一共通过这4步，判断出客户端处于什么类型的NAT下，"></a>到这里STUN Server一共通过这4步，判断出客户端处于什么类型的NAT下，</h6><h6 id="然后去做后续的处理：这4步都会返回给客户端它的公网IP、Port和NAT类型，除此之外："><a href="#然后去做后续的处理：这4步都会返回给客户端它的公网IP、Port和NAT类型，除此之外：" class="headerlink" title="然后去做后续的处理：这4步都会返回给客户端它的公网IP、Port和NAT类型，除此之外："></a>然后去做后续的处理：这4步都会返回给客户端它的公网IP、Port和NAT类型，除此之外：</h6><ul><li>如果B处于公网或者Full Cone Nat下，STUN不做其他的了，因为其他客户端可以直接和A进行通信。</li><li>如果B处于Restrict Cone或者Port Restrict NAT下，STUN还会协调TURN进行NAT打洞。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B请求STUN服务器，</span><br><span class="line">STUN服务器返回ICE NAT类型给B;</span><br><span class="line">STUN服务器协调打洞TURN服务器;</span><br><span class="line">TURN服务器命令A给B打洞，B给A打洞；</span><br><span class="line">B和A通信</span><br></pre></td></tr></table></figure><ul><li>如果A处于对称NAT下，那么点对点连接下，NAT是无法进行打洞的。所以为了通信，只能采取最后的手段了，就是转成C&#x2F;S架构了，STUN会协调TURN进行消息转发（中继）。</li></ul><h5 id="2-TURN-Server也主要做了两件事："><a href="#2-TURN-Server也主要做了两件事：" class="headerlink" title="2.TURN Server也主要做了两件事："></a>2.TURN Server也主要做了两件事：</h5><ul><li><h6 id="为NAT打洞："><a href="#为NAT打洞：" class="headerlink" title="为NAT打洞："></a>为NAT打洞：</h6></li></ul><p>如果A和B要互相通信，那么TURN Server，会命令A和B互相发一条信息，这样各自的NAT就留下了对方的洞，下次他们就可以之间进行通信了。</p><ul><li><h6 id="为对称NAT提供消息转发："><a href="#为对称NAT提供消息转发：" class="headerlink" title="为对称NAT提供消息转发："></a>为对称NAT提供消息转发：</h6></li></ul><p>当A或者B其中一方是对称NAT时，那么给这一方发信息，就只能通过TURN Server来转发了。</p><h4 id="最后补充一下，为什么对称NAT无法打洞："><a href="#最后补充一下，为什么对称NAT无法打洞：" class="headerlink" title="最后补充一下，为什么对称NAT无法打洞："></a>最后补充一下，为什么对称NAT无法打洞：</h4><p>假如A、B进行通信，而B处于对称NAT之下，那么A与B通信，STUN拿到A，B的公网地址和端口号都为10000，然后去协调TURN打洞，那么TURN去命令A发信息给B，则A就在NAT打了个B的洞，但是这个B的洞是端口号为10000的洞，但是下次B如果给A发信息，因为B是对称NAT，它给每个新的IP发送信息时，都重新对应一个公网端口，所以给A发送请求可能是公网10001端口，但是A只有B的10000端口被打洞过，所以B的请求就被丢弃了。<br>显然Server是无法协调客户端打洞的，因为协调客户端打得洞仅仅是上次对端为Server发送端口的洞，并不适用于另一个请求。</p><h5 id="最后的最后再补充一点，就是NAT打的洞也是具有时效性的，如果NAT超时了，那么还是需要重新打洞的。"><a href="#最后的最后再补充一点，就是NAT打的洞也是具有时效性的，如果NAT超时了，那么还是需要重新打洞的。" class="headerlink" title="最后的最后再补充一点，就是NAT打的洞也是具有时效性的，如果NAT超时了，那么还是需要重新打洞的。"></a>最后的最后再补充一点，就是NAT打的洞也是具有时效性的，如果NAT超时了，那么还是需要重新打洞的。</h5><p><strong>文章地址：</strong></p><p>作者：涂耀辉<br>链接：<a href="https://www.jianshu.com/p/84e8c78ca61d">https://www.jianshu.com/p/84e8c78ca61d</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2P通信原理与实现</title>
      <link href="/2022/03/16/P2P%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/03/16/P2P%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>当今互联网到处存在着一些中间件(Middle Boxes),如NAT和防火墙,导致两个(不在同一内网)中的客户端无法直接通信。</p><p>目前部署的中间件多都是在C&#x2F;S架构(client&#x2F;server)上设计的,其中相对隐匿的<strong>客户机</strong>主动向周知的<strong>服务端</strong>(拥有静态IP地址和DNS名称)发起链接请求. 大多数中间件实现了一种<strong>非对称的通讯模型</strong>,即内网中的主机可以初始化对外的链接,而外网的主机却不能初始化对内网的链接, 除非经过中间件管理员特殊配置。</p><blockquote><p>前言</p></blockquote><p>在中间件为常见的NAPT的情况下（也是本文主要讨论的）,内网中的<strong>客户端</strong>没有单独的公网IP地址, 而是通过NAPT转换,和其他同一内网用户共享一个公网IP. 这种内网主机隐藏在中间件后的不可访问性对于一些客户端软件如浏览器来说并不是一个问题,因为其只需要初始化对外的链接,从某方面来看反而还对隐私保护有好处。</p><p>然而在P2P应用中, 内网主机（客户端）需要对另外的终端（Peer）直接建立链接,但是发起者和响应者可能在<strong>不同的中间件</strong>后面, 两者都没有公网IP地址. 而外部对NAT公网IP和端口主动的链接或数据都会因内网未请求被丢弃掉. 本文讨论的就是如何跨越NAT<strong>实现内网主机</strong>直接通讯的问题。</p><p>内网主机，即局域网中的机器；外网主机，经互联网访问局域网的机器。</p><blockquote><p>一些术语</p></blockquote><h3 id="防火墙-Firewall"><a href="#防火墙-Firewall" class="headerlink" title="防火墙(Firewall)"></a>防火墙(Firewall)</h3><p>防火墙主要限制内网和公网的通讯,通常<strong>丢弃</strong>未经许可的数据包. 防火墙会检测(但是不修改)试图进入内网数据包的IP地址和TCP&#x2F;UDP端口信息.</p><h3 id="网络地址转换器-NAT"><a href="#网络地址转换器-NAT" class="headerlink" title="网络地址转换器(NAT)"></a>网络地址转换器(NAT)</h3><p>NAT不止检查进入数据包的头部,而且对其进行修改,从而实现<strong>同一内网中不同主机共用更少的公网IP</strong>（通常是一个）.</p><p>网络地址转换（Network Address Translation，缩写为NAT），也叫做网络掩蔽或者IP掩蔽（IP masquerading），是一种在IP数据包通过路由器或防火墙时<strong>重写来源IP地址或目的IP地址</strong>的技术。这种技术被普遍使用在<strong>有多台主机但只通过一个公有IP地址</strong>访问因特网的私有网络中。根据规范，路由器是不能这样工作的，但它的确是一个方便且得到了广泛应用的技术。当然，NAT也让主机之间的通信变得复杂，导致了通信效率的降低。</p><p>Nat的类型分为<strong>基本NAT(Basic NAT)</strong> 和 **网络地址-端口转换器(NAPT)**。</p><h4 id="基本NAT-Basic-NAT"><a href="#基本NAT-Basic-NAT" class="headerlink" title="基本NAT(Basic NAT)"></a>基本NAT(Basic NAT)</h4><p>基本NAT会将内网主机的IP地址映射为一个公网IP,不改变其TCP&#x2F;UDP端口号. 基本NAT通常只有在当NAT有<strong>公网IP池</strong>的时候才有用.</p><p>它实现比较简单，仅支持地址转换，不支持端口映射。Basic NAT要维护一个无端口号NAT表，结构如下：</p><table><thead><tr><th>内网IP</th><th>外网IP</th></tr></thead><tbody><tr><td>192.168.1.155</td><td>219.152.168.222</td></tr><tr><td>192.168.1.159</td><td>219.152.168.223</td></tr><tr><td>192.168.1.151</td><td>219.152.168.224</td></tr></tbody></table><h4 id="网络地址-端口转换器-NAPT"><a href="#网络地址-端口转换器-NAPT" class="headerlink" title="网络地址-端口转换器(NAPT)"></a>网络地址-端口转换器(NAPT)</h4><p>到目前为止最常见的即为NAPT,其检测并修改出入数据包的<strong>IP地址和端口号</strong>,从而允许多个内网主机同时共享一个公网IP地址.</p><p>1.全锥形NAT(Full Cone NAT)</p><p>   初始状态时，Client与Server1、Client与Server2都没有通讯过。</p><p>   当Client通过NAT向Server1发送一个packet后，NAT会生成如下一行映射。</p><table><thead><tr><th>Client主机地址：端口</th><th>NAT公网地址:端口</th></tr></thead><tbody><tr><td>192.168.1.5:5000</td><td>210.21.12.140:8000</td></tr></tbody></table><p>这边看到，<strong>内网的ip和端口</strong>已经和<strong>公网的ip和端口</strong>对应了。</p><p>​        在全锥型网络下，后续当Server1要发送数据到Client时，Server1首先将数据送到       NAT（210.21.12.140:8000），NAT接收到该报文，会将该报文转发给Client（192.168.1.5:5000）。<br>​         在全锥型网络下，Server2要发送数据给Client，Server2也是需要先将数据发送到NAT（210.21.12.140:8000），NAT接收到该报文，会将该报文转发给Client（192.168.1.5:5000）。</p><p>因为NAT上已经有了192.168.1.5:5000到210.21.12.140:8000的映射。  </p><p>注：这边的关键点是client主机的内网和公网的IP和端口的对应。</p><p>2.受限锥形NAT(Restricted Cone NAT)</p><p>   初始状态时，Client与Server1、Client与Server2都没有通讯过。</p><p>   当Client通过NAT向Server1发送一个packet后，NAT中会生成如下一行映射（注意，这里增加了一项IP地址的限制）。</p><table><thead><tr><th>Client主机地址：端口</th><th>NAT公网地址:端口</th><th>Server主机地址：端口</th></tr></thead><tbody><tr><td>192.168.1.5:5000</td><td>210.21.12.140:8000</td><td>210.15.27.166</td></tr></tbody></table><p>   在受限圆锥型NAT下，Server1要发送数据到Client时，Server1首先将数据送到NAT（210.21.12.140:8000），NAT接收到该报文，会将该报文转发给Client（192.168.1.5:5000）。<br>   并且Server1主机的<strong>任何端口号</strong>数据，都可以将数据送到NAT（210.21.12.140:8000），NAT都会将该报文转给Client（192.168.1.5:5000）。</p><p>   但是Server2主机无法与Client主机进行通讯。因为Client从来没有和Server2通信过，NAT将拒绝Server2试图与Client连接的动作。</p><p>3.端口受限锥形NAT(Port-Restricted Cone NAT)</p><p>  端口受限锥形NAT也类似,只当外部数据包的<strong>IP地址和端口号都匹</strong>配内网主机发送过的地址和端口号时才进行转发。</p><p>​初始状态时，Client与Server1、Client与Server2都没有通讯过。</p><p>​当Client通过NAT向Server1发送一个packet后，NAT中会生成如下一行映射（注意，这里增加了IP+port限制）。</p><table><thead><tr><th>Client主机地址：端口</th><th>NAT公网地址:端口</th><th>Server主机地址：端口</th></tr></thead><tbody><tr><td>192.168.1.5:5000</td><td>210.21.12.140:8000</td><td>210.15.27.166:80</td></tr></tbody></table><p>​在端口受限圆锥型NAT下，Server2无法与Client通信，因为Client从来没有和Server2通信过。<br>​并且Server1也只能用它的210.15.27.166:80与Client的192.168.1.5:5000通信，因为Client也从来没有和Server1的<strong>其他端口</strong>通信过。<br>​       备注：家用路由器大部分都属于端口受限圆锥型NAT。</p><p>4.对称NAT(Symmetric NAT)</p><p>对称NAT正好相反,不在所有公网-内网对的会话中维持一个固定的端口绑定. 其为每个新的会话开辟一个新的端口。</p><p>​初始状态时，Client与Server1、Client与Server2都没有通讯过。</p><p>​当Client通过NAT向Server1发送一个packet后，NAT中会生成如下一行映射   </p><table><thead><tr><th>Client主机地址：端口</th><th>NAT公网地址:端口</th><th>Server主机地址：端口</th></tr></thead><tbody><tr><td>192.168.1.5:5000</td><td>210.21.12.140:8000</td><td>210.15.27.166:80</td></tr></tbody></table><p>​接下来Client要使用相同的端口和Server2通信，将会在NAT中生成如下映射表。 </p><table><thead><tr><th>Client主机地址：端口</th><th>NAT公网地址:端口</th><th>Server主机地址：端口</th></tr></thead><tbody><tr><td>192.168.1.5:5000</td><td>210.21.12.140:8000</td><td>210.15.27.166:80</td></tr><tr><td>192.168.1.5:5000</td><td>210.21.12.140:8001</td><td>210.15.27.140:80</td></tr></tbody></table><p>​Server1只能用它的210.15.27.166:80通过NAT的 210.21.12.140:8000与Client的192.168.1.5:5000通信。<br>​Server2也只能用它的210.15.27.140:80通过NAT的210.21.12.140:8001与Client的192.168.1.5:5000通信，<br>​Server1或者Server2的其他端口则均不能和Client的192.168.1.5:5000通信。</p><ul><li>Cone Nat和 对称NAT 差别</li></ul><p>Cone Nat 中Client内网ip及端口映射Nat的公网ip及端口是一对一关系。</p><p>对称NAT  中Client内网ip及端口映射Nat的公网ip及端口是一对多关系。</p><blockquote><p>P2P通信技术</p></blockquote><p>根据客户端的不同,客户端之间进行P2P传输的方法也略有不同,这里介绍了现有的穿越中间件进行P2P通信的几种技术.</p><h3 id="中继（Relaying）"><a href="#中继（Relaying）" class="headerlink" title="中继（Relaying）"></a>中继（Relaying）</h3><p>这是最可靠但也是最低效的一种P2P通信实现. 其原理是通过一个有公网IP的服务器中间人对两个内网客户端的通信数据进行中继和转发. 如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                       Server S</span><br><span class="line">                          |</span><br><span class="line">                          |</span><br><span class="line">   +----------------------+----------------------+</span><br><span class="line">   |                                             |</span><br><span class="line"> NAT A                                         NAT B</span><br><span class="line">   |                                             |</span><br><span class="line">   |                                             |</span><br><span class="line">Client A                                      Client B</span><br></pre></td></tr></table></figure><p><strong>客户端A和客户端B不直接通信,而是先都与服务端S建立链接,然后再通过S和对方建立的通路来中继传递的数据</strong>。这钟方法的缺陷很明显, 当链接的客户端变多之后,会显著增加服务器的负担,完全没体现出P2P的优势. 但这种方法的好处是能保证成功,因此在实践中也常作为一种备选方案。</p><h3 id="逆向链接（Connection-reversal）"><a href="#逆向链接（Connection-reversal）" class="headerlink" title="逆向链接（Connection reversal）"></a>逆向链接（Connection reversal）</h3><p>第二种方法在当两个端点中有一个不存在中间件的时候有效. 例如,客户端A在NAT之后而客户端B拥有全局IP地址,如下图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                            Server S</span><br><span class="line">                        18.181.0.31:1235</span><br><span class="line">                               |</span><br><span class="line">                               |</span><br><span class="line">        +----------------------+----------------------+</span><br><span class="line">        |                                             |</span><br><span class="line">      NAT A                                           |</span><br><span class="line">155.99.25.11:62000                                    |</span><br><span class="line">        |                                             |</span><br><span class="line">        |                                             |</span><br><span class="line">     Client A                                      Client B</span><br><span class="line">  10.0.0.1:1234                               138.76.29.7:1234　</span><br></pre></td></tr></table></figure><p>客户端A内网地址为10.0.0.1,且应用程序正在使用TCP端口1234。<strong>A和服务器S</strong>建立了一个链接,服务器的IP地址为18.181.0.31,监听1235端口. NAT A给客户端A分配了TCP端口62000,地址为NAT的公网IP地址155.99.25.11, 作为客户端A对外当前会话的临时IP和端口. 因此S认为客户端A就是155.99.25.11:62000. 而B由于有公网地址,所以对S来说B就是138.76.29.7:1234.</p><p>当客户端B想要发起一个对客户端A的P2P链接时,要么链接A的外网地址155.99.25.11:62000,要么链接A的内网地址10.0.0.1:1234,然而两种方式链接都会失败。链接10.0.0.1:1234失败自不用说,为什么链接155.99.25.11:62000也会失败呢？来自B的TCP SYN握手请求到达NAT A的时候会被拒绝,<strong>因为对NAT A来说只有外出的链接才是允许的</strong>。 在直接链接A失败之后,B可以通过S向A中继一个链接请求,从而<strong>从A方向</strong>“逆向“地建立起A-B之间的点对点链接。</p><p>很多当前的P2P系统都实现了这种技术,但其局限性也是很明显的,只有当其中一方有公网IP时链接才能建立. 越来越多的情况下, 通信的双方都在NAT之后,因此就要用到我们下面介绍的第三种技术了.</p><h3 id="UDP打洞（UDP-hole-punching）"><a href="#UDP打洞（UDP-hole-punching）" class="headerlink" title="UDP打洞（UDP hole punching）"></a>UDP打洞（UDP hole punching）</h3><p>第三种P2P通信技术,被广泛采用的,名为“P2P打洞“. P2P打洞技术<strong>依赖于通常防火墙和Cone NAT允许正当的P2P应用程序</strong>在中间件中打洞且与对方建立直接链接的特性。</p><p>下面主要考虑两种常见的场景,以及应用程序如何设计去完美地处理这些情况，</p><ul><li>第一种场景代表了大多数情况,即两个需要直接链接的客户端处在两个不同的NAT之后； </li><li>第二种场景是两个客户端在同一个NAT之后,但客户端自己可能并不知道(比如同一ISP下面的不同子网)。</li></ul><blockquote><p>端点在不同的NAT之后</p></blockquote><p>假设客户端A和客户端B的地址都是内网地址,且在不同的NAT后面。A、B上运行的P2P应用程序和服务器S都使用了UDP端口1234,A和B分别初始化了 与Server的UDP通信,地址映射如图所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                            Server S</span><br><span class="line">                        18.181.0.31:1234</span><br><span class="line">                               |</span><br><span class="line">                               |</span><br><span class="line">        +----------------------+----------------------+</span><br><span class="line">        |                                             |</span><br><span class="line">      NAT A                                         NAT B</span><br><span class="line">155.99.25.11:62000                            138.76.29.7:31000</span><br><span class="line">        |                                             |</span><br><span class="line">        |                                             |</span><br><span class="line">     Client A                                      Client B</span><br><span class="line">  10.0.0.1:1234                                 10.1.1.3:1234</span><br></pre></td></tr></table></figure><p>现在假设客户端A打算与客户端B直接建立一个UDP通信会话. 如果A直接给B的公网地址138.76.29.7:31000发送UDP数据,NAT B将很可能会无视进入的数据 (除非是Full Cone NAT),因为源地址和端口与S不匹配,而最初只与S建立过会话. B往A直接发信息也类似。</p><p>假设A开始给B的公网地址发送UDP数据的同时,给服务器S发送一个中继请求,要求B开始给A的公网地址发送UDP信息。A往B的输出信息会导致NAT A打开 一个A的内网地址与与B的外网地址之间的新通讯会话,B往A亦然。 一旦新的UDP会话在两个方向都打开之后,客户端A和客户端B就能直接通讯, 而无须再通过引导服务器S了。</p><p>上面这段话其实不太明白,可以看看这段话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）ClientA请求Server。</span><br><span class="line">（2）ClientB请求Server。</span><br><span class="line">（3）Server把ClientA的公网IP和端口信息发给ClientB,NAT B打开 一个B的内网地址与与A的外网地址之间的新通讯会话。</span><br><span class="line">（4）Server把ClientB的公网IP和端口信息发给ClientA,NAT A打开 一个A的内网地址与与B的外网地址之间的新通讯会话。</span><br><span class="line">（5）ClientA发送信息给ClientB发消息。（A信任B）</span><br><span class="line">（6）ClinetB发送信息给ClientA发消息。（B信任A）</span><br><span class="line">（7）连接已经建立。两者可以直接通信了。</span><br></pre></td></tr></table></figure><p>UDP打洞技术有许多有用的性质. 一旦一个的P2P链接建立,链接的双方都能反过来作为“引导服务器”来帮助其他中间件后的客户端进行打洞, 极大减少了服务器的负载. 应用程序不需要知道中间件具体是什么（如果有的话）,因为以上的过程在没有中间件或者有多个中间件的情况下 也一样能建立通信链路。</p><blockquote><p>端点在相同的NAT之后</p></blockquote><p>现在考虑这样一种情景,两个客户端A和B正好在同一个NAT之后（而且可能他们自己并不知道）,因此在同一个内网网段之内. 客户端A和服务器S建立了一个UDP会话,NAT为此分配了公网端口62000,B同样和S建立会话,分配到了端口62001,如下图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                          Server S</span><br><span class="line">                      18.181.0.31:1234</span><br><span class="line">                             |</span><br><span class="line">                             |</span><br><span class="line">                            NAT</span><br><span class="line">                   A-S 155.99.25.11:62000</span><br><span class="line">                   B-S 155.99.25.11:62001</span><br><span class="line">                             |</span><br><span class="line">      +----------------------+----------------------+</span><br><span class="line">      |                                             |</span><br><span class="line">   Client A                                      Client B</span><br><span class="line">10.0.0.1:1234                                 10.1.1.3:1234</span><br></pre></td></tr></table></figure><p>假设A和B使用了上节介绍的UDP打洞技术来建立P2P通路,那么会发生什么呢？首先A和B会得到由S观测到的对方的公网IP和端口号,然后给对方的地址发送信息。</p><p>两个客户端只有在NAT允许内网主机对内网其他主机发起UDP会话的时候才能正常通信,我们把这种情况称之为”回环传输“(loopback transmission),因为从内部 到达NAT的数据会被“回送”到内网中而不是转发到外网。 例如,当A发送一个UDP数据包给B的公网地址时,数据包最初有源IP地址和端口地址10.0.0.1:1234和 目的地址155.99.25.11:62001,NAT收到包后,将其转换为源155.99.25.11:62000（A的公网地址）和目的10.1.1.3:1234,然后再转发给B。即便NAT支持 回环传输,这种转换和转发在此情况下也是没必要的,且有可能会增加A与B的对话延时和加重NAT的负担。</p><p>对于这个情况,优化方案是很直观的. 当A和B最初通过S交换地址信息时,他们应该包含自身的IP地址和端口号（从自己看）,同时也包含从服务器看的自己的 地址和端口号. 然后客户端同时开始从对方已知的两个的地址中同时开始互相发送数据,并使用第一个成功通信的地址作为对方地址。如果两个客户端在同一个 NAT后,发送到对方内网地址的数据最有可能先到达,从而可以<strong>建立一条不经过NAT的通信链路</strong>；如果两个客户端在不同的NAT之后,发送给对方内网地址的数据包 根本就到达不了对方,但仍然可以通过公网地址来建立通路. 值得一提的是,虽然这些数据包通过某种方式验证,但是在不同NAT的情况下完全有可能会导致A往B 发送的信息发送到其他A内网网段中无关的结点上去的。</p><blockquote><p>端点在多级NAT之后</p></blockquote><p>在一些拓朴结构中,可能会存在多级NAT设备,在这种情况下,如果没有关于拓朴的具体信息, 两个Peer要建立“最优”的P2P链接是不可能的,下面来说为什么. 以下图为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                          Server S</span><br><span class="line">                        18.181.0.31:1234</span><br><span class="line">                               |</span><br><span class="line">                               |</span><br><span class="line">                             NAT X</span><br><span class="line">                     A-S 155.99.25.11:62000</span><br><span class="line">                     B-S 155.99.25.11:62001</span><br><span class="line">                               |</span><br><span class="line">                               |</span><br><span class="line">        +----------------------+----------------------+</span><br><span class="line">        |                                             |</span><br><span class="line">      NAT A                                         NAT B</span><br><span class="line">192.168.1.1:30000                             192.168.1.2:31000</span><br><span class="line">        |                                             |</span><br><span class="line">        |                                             |</span><br><span class="line">     Client A                                      Client B</span><br><span class="line">  10.0.0.1:1234                                 10.1.1.3:1234</span><br></pre></td></tr></table></figure><p>假设NAT X是一个网络提供商ISP部署的工业级NAT,其下子网共用一个公网地址155.99.25.11,NAT A和NAT B分别是其下不同用户的网关部署的NAT. 只有服务器S 和NAT X有全局的路由地址. Client A在NAT A的子网中,同时Client B在NAT B的子网中,每经过一级NAT都要进行一次网络地址转换.</p><p>现在假设A和B打算建立直接P2P链接,用一般的方法（通过Server S来打洞）自然是没问题的,那能不能优化呢？一种想当然的优化办法是A直接把信息发送给NAT B的 内网地址192.168.1.2:31000,且B通过NAT B把信息发送给A的路由地址192.168.1.1:30000,不幸的是,A和B都没有办法得知这两个目的地址,因为S只看见了客户端 ‵全局‵地址155.99.25.11. 退一步说,即便A和B通过某种方法得知了那些地址,我们也无法保证他们是可用的. 因为ISP分配的子网地址可能和NAT A B分配的子网地址 域相冲突. 因此客户端没有其他选择,只能使用S来进行打洞并进行回环传输.</p><h2 id="固定端口绑定"><a href="#固定端口绑定" class="headerlink" title="固定端口绑定"></a>固定端口绑定</h2><p>UDP打洞技术有一个主要的条件：只有当两个NAT都是Cone NAT（或者非NAT的防火墙）时才能工作. 因为其维持了一个给定的（内网IP,内网UDP）二元组 和（公网IP, 公网UDP）二元组固定的端口绑定,只要该UDP端口还在使用中,就不会变化。如果像对称NAT一样,给每个新会话分配一个新的公网端口,就 会导致UDP应用程序无法使用跟外部端点已经打通了的通信链路. 由于Cone NAT是当今最广泛使用的,尽管有一小部分的对称NAT是不支持打洞的,UDP打洞 技术也还是被广泛采纳应用。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>一般的网络编程,都是客户端比服务端要难,因为要处理与服务器的通信同时还要处理来自用户的事件；对于P2P客户端来说更是如此,因为P2P客户端不止作 为客户端,同时也作为对等连接的服务器端. 这里的大体思路是,输入命令传输给服务器之后,接收来自服务器的反馈,并执行相应代码. 例如A想要与B建立 通信链路,先给服务器发送punch命令以及给B发送数据,服务器接到命令后给B发送punch_requst信息以及A的端点信息,B收到之后向A发送数据打通通路,然 后A与B就可以进行P2P通信了. 经测试,打通通路后即便把服务器关闭,A与B也能正常通信.</p><p>一个UDP打洞的例子见<a href="https://github.com/evilpan/P2P-Over-MiddleBoxes-Demo">P2P-Over-MiddleBoxes-Demo</a></p><h1 id="TCP打洞-TCP-Hole-Punching"><a href="#TCP打洞-TCP-Hole-Punching" class="headerlink" title="TCP打洞(TCP Hole Punching)"></a>TCP打洞(TCP Hole Punching)</h1><p>关于TCP打洞,有一点需要提的是,因为TCP是基于连接的,所以任何未经连接而发送的数据都会被丢弃,这导致在recv的时候是无法直接从peer端读取数据. 其实这对UDP也一样,如果对UDP的socket进行了connect,其也会忽略连接之外的数据,详见<code>connect(2)</code>.</p><p>所以,如果我们要进行TCP打洞,通常需要重用本地的endpoint来发起新的TCP连接,这样才能将已经打开的NAT利用起来. 具体来说,则是要设置socket的 <code>SO_REUSEADDR</code>或<code>SO_REUSEPORT</code>属性,根据系统不同,其实现也不尽一致. 一般来说,TCP打洞的步骤如下：</p><ul><li>A 发送 SYN 到 B(出口地址,下同）,从而创建NAT A的一组映射</li><li>B 发送 SYN 到 A, 创建NAT B的一组映射</li><li>根据时序不同,两个SYN中有一个会被对方的NAT丢弃,另一个成功通过NAT</li><li>通过NAT的SYN报文被其中一方收到,即返回SYNACK, 完成握手</li><li>至此,TCP的打洞成功,获得一个不依赖于服务器的链接</li></ul><p>参考文章：</p><p><a href="https://blog.csdn.net/CrystalShaw/article/details/80677966">NAT类型及工作原理</a></p><p><a href="https://www.pianshen.com/article/9679170640/">计算机网络：NAT基本原理</a></p><p><a href="https://evilpan.com/2015/10/31/p2p-over-middle-box/">P2P通信原理与实现</a></p><p><a href="https://blog.csdn.net/u011580175/article/details/71001796/">UDP打洞（成功打洞）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R系列-2</title>
      <link href="/2021/11/24/R%E7%B3%BB%E5%88%97-2/"/>
      <url>/2021/11/24/R%E7%B3%BB%E5%88%97-2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>R系列-1</title>
      <link href="/2021/11/24/R%E7%B3%BB%E5%88%97-1/"/>
      <url>/2021/11/24/R%E7%B3%BB%E5%88%97-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>缓存雪崩 (大量key失效，导致大量访问，犹如雪崩)</p></blockquote><p>在<code>高并发</code>场景下，大量缓存key在<code>同一时间失效</code>，造成大量请求直接落在数据库上，导致数据库宕机。</p><p>解决方案:</p><ul><li>随机设置key失效时间，避免大量key集体失效。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setRedis（Key，value，time + Math.random() * 10000）；</span><br></pre></td></tr></table></figure><ul><li>若是集群部署，可将热点数据均匀分布在不同的Redis库中也能够避免key全部失效问题</li><li>不设置过期时间</li><li>跑定时任务，在缓存失效前刷进新的缓存</li></ul><blockquote><p>缓存穿透(绕过redis，实现穿透)</p></blockquote><p><code>redis缓存</code>和<code>数据库</code>中没有相关数据(例用户直接携带<code>id&lt;=0</code>的参数不断发起请求)，redis中没有这样的数据，<code>无法进行拦截</code>，直接被穿透到<code>数据库</code>，导致数据库压力过大宕机。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>对不存在的数据缓存到redis中，设置key，value值为null(不管是数据未null还是系统bug问题)，并设置一个短期过期时间段，避免过期时间过长影响正常用户使用。</li><li>拉黑该IP地址</li><li>对参数进行校验，不合法参数进行拦截<code>(认为最有效的之一)</code></li><li>布隆过滤器 将所有可能存在的数据哈希到一个足够大的bitmap(位图)中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<code>(认为最有效的之一)</code></li></ul><blockquote><p>缓存击穿 (对一个点高频打击，然后穿透)</p></blockquote><p><code>某一个</code>热点key，在不停地扛着高并发，当这个热点key在<code>失效的一瞬间</code>，持续的高并发访问就<code>击破缓存</code>直接访问数据库，导致数据库宕机。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>设置热点数据”永不过期”</p></li><li><p>加上互斥锁：上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它</p><p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后将数据放到redis缓存起来。后面的线程进来发现已经有缓存了，就直接走缓存</p></li></ul><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>雪崩是<code>大面积</code>的key缓存失效；穿透是redis里<code>不存在</code>这个缓存key；击穿是redis<code>某一个热点</code>key突然失效，最终的受害者都是数据库。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><code>未雨绸缪</code>：将redis、MySQL等搭建成高可用的集群，防止单点。</p><p><code>亡羊补牢</code>：服务中进行限流 + 降级，防止MySQL被打崩溃。</p><p><code>重振旗鼓</code>：Redis 持久化 RDB+AOF，宕机重启，自动从磁盘上加载数据，快速恢复缓存数据</p><p><a href="https://juejin.cn/post/6872536898003271687">原文链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go的一些认知使用</title>
      <link href="/2021/10/27/go%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/10/27/go%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="本篇观点不一定正确，目前仅供个人使用"><a href="#本篇观点不一定正确，目前仅供个人使用" class="headerlink" title="本篇观点不一定正确，目前仅供个人使用"></a>本篇观点不一定正确，目前仅供个人使用</h2><blockquote><p>数组和切片区别</p></blockquote><p>数组是固定的，但切片有扩展性<code>append</code></p><blockquote><p>切片和map</p></blockquote><p>其实map可以当做一个类型，可以存储字符串</p><blockquote><p>map嵌套</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a := map[string]map[string]string&#123;&#125;</span><br><span class="line">b,ok := a[&quot;name&quot;]</span><br><span class="line">if !ok &#123;</span><br><span class="line">    b := make(map[string]string)</span><br><span class="line">    a[&quot;name&quot;] = b</span><br><span class="line">    b[&quot;xiaoming&quot;] = &quot;go&quot;</span><br><span class="line">    b[&quot;xiaodong&quot;] = &quot;why&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>struct 继承和重组</p></blockquote><p>结构体，对象。可以通过指针关联方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/z226688/article/details/108963110</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GO入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展管理工具composer</title>
      <link href="/2021/10/09/%E6%89%A9%E5%B1%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7composer/"/>
      <url>/2021/10/09/%E6%89%A9%E5%B1%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7composer/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为最热门的php的扩展工具，<code>composer</code>在各个php框架基本都会用到，本文介绍一下实用常规操作。</p><h3 id="composer的作用"><a href="#composer的作用" class="headerlink" title="composer的作用"></a>composer的作用</h3><p>Composer是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。</p><h3 id="初始化扩展包"><a href="#初始化扩展包" class="headerlink" title="初始化扩展包"></a>初始化扩展包</h3><p>先创建一个空目录，再在空目录里执行 Composer 自带的 init 命令，自动生成 Composer 的配置文件(composer.json)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir composer_test</span><br><span class="line">$ cd composer_test</span><br><span class="line">$ composer init</span><br></pre></td></tr></table></figure><p><strong>请注意：</strong> Minimum Stability(官方说明) 要输入 dev，表明我们的扩展包最小稳定版的开发版。否则 Composer 的默认 Minimum Stability 是 stable，扩展包需要打上版本号才能被 Composer 认为是稳定版(stable)，前期开发调试时简单点处理，设置为 dev，这样引入开发中的 Composer 扩展包时不需要去管什么版本号，等开发调试过了再说。</p><p>type 字段的<a href="https://getcomposer.org/doc/04-schema.md#type">官方说明</a>。<br>version 字段的<a href="https://getcomposer.org/doc/04-schema.md#version">官方说明</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    Welcome to the Composer config generator</span><br><span class="line"></span><br><span class="line">This command will guide you through creating your composer.json config.</span><br><span class="line"></span><br><span class="line">Package name (&lt;vendor&gt;/&lt;name&gt;) [waq/composer_test]:</span><br><span class="line">Description []:</span><br><span class="line">Author [晴x &lt;24xxxxxx50@qq.com&gt;, n to skip]:</span><br><span class="line">Minimum Stability []: dev</span><br><span class="line">Package Type (e.g. library, project, metapackage, composer-plugin) []:</span><br><span class="line">License []:</span><br><span class="line"></span><br><span class="line">Define your dependencies.</span><br><span class="line"></span><br><span class="line">Would you like to define your dependencies (require) interactively [yes]? yes</span><br><span class="line">Search for a package:</span><br><span class="line">Would you like to define your dev dependencies (require-dev) interactively [yes]? yes</span><br><span class="line">Search for a package:</span><br><span class="line">Add PSR-4 autoload mapping? Maps namespace &quot;Waq\ComposerTest&quot; to the entered relative path. [src/, n to skip]:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;waq/composer_test&quot;,</span><br><span class="line">    &quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;Huangyanyu\\ComposerTest\\&quot;: &quot;src/&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;晴x&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;24xxxxxx50@qq.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;minimum-stability&quot;: &quot;dev&quot;,</span><br><span class="line">    &quot;require&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Do you confirm generation [yes]? y</span><br><span class="line">Generating autoload files</span><br><span class="line">Generated autoload files</span><br><span class="line">PSR-4 autoloading configured. Use &quot;namespace Waq\ComposerTest;&quot; in src/</span><br><span class="line">Include the Composer autoloader with: require &#x27;vendor/autoload.php&#x27;;</span><br></pre></td></tr></table></figure><h3 id="包的环境要求和自动加载规范"><a href="#包的环境要求和自动加载规范" class="headerlink" title="包的环境要求和自动加载规范"></a>包的环境要求和自动加载规范</h3><p>环境要求通过 composer.json 里的 require 字段来限制。</p><p>自动加载规范通过 autoload 字段来定义。</p><p>现在假定需要 PHP 的版本大于等于 7.0.0，并且当前包的 src 目录下的文件以 Waq\ComposerTest 命令空间来加载，在 composer.json 中增加以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;require&quot;: &#123;</span><br><span class="line">  &quot;php&quot;: &quot;&gt;=7.0&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;autoload&quot;: &#123;</span><br><span class="line">  &quot;psr-4&quot;: &#123;</span><br><span class="line">    &quot;Waq\\ComposerTest\\&quot;: &quot;src&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要引入其他的非 PSR-4 规范的源码文件，可能会需要用到 autoload 下的 file(官方说明) 字段，每一次请求 PHP 时都是包含这些文件。</p><p>例如要包含钉钉 SDK 的代码，可以在 composer.json 中增加以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;autoload&quot;: &#123;</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;lib/taobao-sdk-PHP/TopSdk.php&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展包里创建类文件"><a href="#扩展包里创建类文件" class="headerlink" title="扩展包里创建类文件"></a>扩展包里创建类文件</h3><p>src 目录下新建 Calc.php 文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace Waq\ComposerTest;</span><br><span class="line"></span><br><span class="line">class Calc</span><br><span class="line">&#123;</span><br><span class="line">    // 计算平方值</span><br><span class="line">    public function square($val)</span><br><span class="line">    &#123;</span><br><span class="line">        return $val * $val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在项目中引入本地的扩展包"><a href="#在项目中引入本地的扩展包" class="headerlink" title="在项目中引入本地的扩展包"></a>在项目中引入本地的扩展包</h3><p>项目要引入本地目录的扩展包，先要在 composer.json 文件中加入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;repositories&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;type&quot;: &quot;path&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;/Users/waq/project/composer_test&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后在项目目录下执行 Composer 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require waq/composer_test:@dev</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require waq/composer_test:dev-master</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面命令中的 <code>waq/composer_test</code> 就是 Composer 扩展包里 composer.json 的 name 字段值。@dev 或 dev-master 表示引入的扩展包是主分支的最新版，当还未将扩展包提交到 Github 仓库或者发布到 Packagist 上时，一般这样引入扩展包。</p><h3 id="测试项目中引入的本地扩展包"><a href="#测试项目中引入的本地扩展包" class="headerlink" title="测试项目中引入的本地扩展包"></a>测试项目中引入的本地扩展包</h3><p>新建测试 PHP 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$calc = new \Waq\ComposerTest\Calc();</span><br><span class="line">echo $calc-&gt;square(&#x27;12&#x27;);</span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>composer install</code> 安装依赖包，当你下载一个项目后，这或许是你改做的第一件事。</p><p><code>composer require/update</code> 更新依赖包，我更喜欢用composer require。</p><p><code>composer remove</code> 卸载依赖包</p><h3 id="指定版本"><a href="#指定版本" class="headerlink" title="指定版本"></a>指定版本</h3><p>update则无法在命令行传入新的版本号，需要先手动在<code>composer.json</code>中指定<strong>新的版本号</strong>，然后执行更新命令。但require可以直接在命令行传入版本号，例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require hashids/hashids:2.0.0</span><br></pre></td></tr></table></figure><p>升级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require hashids/hashids:3.0.0</span><br></pre></td></tr></table></figure><p>降级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require hashids/hashids:2.0.4</span><br></pre></td></tr></table></figure><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>版本号范围大于&#x2F;大于等于：<code>&gt;1.2.3</code> <code> &gt;=1.2.3</code></p><p>小于&#x2F;小于等于：<code>&lt;1.2.3</code> <code> &lt;=1.2.3</code></p><p>确切的版本号：<code>1.2.3</code></p><p>~1.2.3: <code>1.2.3 &lt;= version &lt; 1.3</code></p><p>^1.2.3: <code>1.2.3 &lt;= version &lt; 2.0</code></p><h3 id="指定分支"><a href="#指定分支" class="headerlink" title="指定分支"></a>指定分支</h3><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h3 id="全局参数-常用"><a href="#全局参数-常用" class="headerlink" title="全局参数(常用)"></a>全局参数(常用)</h3><ul><li>-v 表示正常输出。</li><li>-vv 表示更详细的输出。</li><li>-vvv 则是为了 debug。</li><li><strong>–help (-h):</strong> 显示帮助信息。</li></ul><h3 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑"></a>常见的坑</h3><blockquote><p><strong>卡着不动</strong></p></blockquote><p>因为某些特殊情况，老外的源特别慢，我们就得把源改为国内的。阿里某个云。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br></pre></td></tr></table></figure><blockquote><p><strong>添加-vvv选项</strong></p></blockquote><p>这样就知道compose这个家伙到底啥情况了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer install -vvv</span><br></pre></td></tr></table></figure><blockquote><p>提示不符合composer.json需要的版本，例如&gt;&#x3D;php7，但实际&lt;php7也能正常运行，所以忽略</p></blockquote><p>这样就可以正常运行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer install --ignore-platform-reqs</span><br></pre></td></tr></table></figure><blockquote><p>Warning from <a href="https://mirrors.aliyun.com/composer">https://mirrors.aliyun.com/composer</a>: Support for Composer 1 is deprecated and some packages will not be available. You should upgrade to Composer 2.</p></blockquote><p>解决方法：<br>更新一下 composer 工具版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer self-update</span><br></pre></td></tr></table></figure><p>出现错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The &quot;https://getcomposer.org/versions&quot; file could not be downloaded: SSL operation failed with code 1.</span><br><span class="line"></span><br><span class="line">解决文章：</span><br><span class="line">https://stackoom.com/question/3t3EF</span><br></pre></td></tr></table></figure><p>具体解决流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">问题：</span><br><span class="line">composer update &quot;xxx/xxx&quot;</span><br><span class="line"></span><br><span class="line">Warning from https://mirrors.aliyun.com/composer: You are using an outdated version of Composer. Composer 2.0 is now available and you should upgrade. See https://getcomposer.org/2</span><br><span class="line"></span><br><span class="line">原因：从报错信息可以看出是composer版本太旧的。</span><br><span class="line"></span><br><span class="line">解决办法：升级本地的composer版本, composer self-update</span><br><span class="line"></span><br><span class="line">执行composer self-update</span><br><span class="line"></span><br><span class="line">macOS: Installing composer fails with error “The ”https://getcomposer.org/versions“ file could not be downloaded: SSL operation failed with code 1”</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line">php -i | grep php.ini</span><br><span class="line"></span><br><span class="line">cat php.ini | grep &quot;openssl.cafile&quot;</span><br><span class="line">cat php.ini | grep &quot;curl.cainfo&quot;</span><br><span class="line"></span><br><span class="line">brew install openssl</span><br><span class="line"></span><br><span class="line">mkdir -p /usr/local/etc/openssl/ curl &#x27;http://curl.haxx.se/ca/cacert.pem&#x27; -o &#x27;/usr/local/openssl/cert.pem&#x27;</span><br><span class="line"></span><br><span class="line">php.ini</span><br><span class="line">openssl.cafile=&quot;/usr/local/etc/openssl/cert.pem&quot;</span><br><span class="line">curl.cainfo=&quot;/usr/local/etc/openssl/cert.pem&quot;</span><br><span class="line"></span><br><span class="line">另外，如果还不行，可以再看看</span><br><span class="line">allow_url_fopen = On  </span><br><span class="line">user_agent=&quot;PHP&quot;  #这个我是；注释的，但不影响</span><br></pre></td></tr></table></figure><p>获取php.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php -i | grep php.ini  或 php --ini</span><br><span class="line"></span><br><span class="line">Configuration File (php.ini) Path =&gt; /usr/local/etc/php/5.6</span><br><span class="line">Loaded Configuration File =&gt; /usr/local/etc/php/5.6/php.ini</span><br></pre></td></tr></table></figure><p>获取cert地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">php -r &quot;print_r(openssl_get_cert_locations());&quot;</span><br><span class="line"></span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [default_cert_file] =&gt; /usr/local/opt/openssl/ssl/cert.pem</span><br><span class="line">    [default_cert_file_env] =&gt; SSL_CERT_FILE</span><br><span class="line">    [default_cert_dir] =&gt; /usr/local/opt/openssl/ssl/certs</span><br><span class="line">    [default_cert_dir_env] =&gt; SSL_CERT_DIR</span><br><span class="line">    [default_private_dir] =&gt; /usr/local/opt/openssl/ssl/private</span><br><span class="line">    [default_default_cert_area] =&gt; /usr/local/opt/openssl/ssl</span><br><span class="line">    [ini_cafile] =&gt; </span><br><span class="line">    [ini_capath] =&gt; </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/weixin_29525745/article/details/116037185">composer指定php,composer 更新指定的依赖包</a></p><p><a href="https://www.freesion.com/article/22651405122/">PHP扩展管理工具COMPOSER的坑、常见问题和解决方法</a></p><p><a href="http://www.thinkphp.cn/code/2430.html">Composer设置忽略版本匹配的方法</a></p><p><a href="https://www.cnblogs.com/aze999/p/15062222.html">Warning from https://mirrors.aliyun.com/composer: Support for Composer 1 is deprecated and some packages will not be available. You should upgrade to Composer 2.</a></p><p><a href="https://www.cnblogs.com/imzhi/p/create-php-composer.html">创建 PHP Composer 包并使用的操作指南</a></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>如果后面有空的话，也可能继续写一篇创建自己的composer包。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据库查看工具</title>
      <link href="/2021/10/08/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/10/08/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><p>Redis Desktop Manager(被推荐，但未使用过)</p></li><li><p>DBeaver(不仅支持redis，还支持多种数据库)</p></li></ul><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://www.jianshu.com/p/214baa511f2e">mac安装Redis可视化工具-Redis Desktop Manager</a></p><p><a href="https://zhile.io/2019/05/08/dbeaver-license-crack.html">DBeaver Enterprise 21.0 企业版激活方法</a></p><h2 id="DBeaver配置"><a href="#DBeaver配置" class="headerlink" title="DBeaver配置"></a>DBeaver配置</h2><p><img src="/2021/10/08/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7/r_1.png"></p><blockquote><p>Mac查询文件</p></blockquote><p>mdfind -name 文件名字</p><blockquote><p>Mac查询文本</p></blockquote><p>mdfind “John”<br>mdfind -onlyin ~&#x2F;Library txt</p><blockquote><p>dbeaver.ini文件地址</p></blockquote><p>&#x2F;Applications&#x2F;DBeaverEE.app&#x2F;Contents&#x2F;Eclipse&#x2F;dbeaver.ini</p><blockquote><p>dbeaver.ini内容</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-startup</span><br><span class="line">../Eclipse/plugins/org.eclipse.equinox.launcher_1.6.0.v20200915-1508.jar</span><br><span class="line">--launcher.library</span><br><span class="line">../Eclipse/plugins/org.eclipse.equinox.launcher.cocoa.macosx.x86_64_1.2.0.v20200915-1442</span><br><span class="line">-vm</span><br><span class="line">/Library/Java/JavaVirtualMachines/openjdk-12.0.1.jdk/Contents/Home/bin/java</span><br><span class="line">-vmargs</span><br><span class="line">-XX:+IgnoreUnrecognizedVMOptions</span><br><span class="line">--add-modules=ALL-SYSTEM</span><br><span class="line">-Dosgi.requiredJavaVersion=11</span><br><span class="line">-Xms128m</span><br><span class="line">-Xmx2048m</span><br><span class="line">-XstartOnFirstThread</span><br><span class="line">-javaagent:/Applications/DBeaverEE.app/dbeaver-agent/dbeaver-agent.jar</span><br></pre></td></tr></table></figure><blockquote><p>使用方法:</p></blockquote><ol><li>在打开的dbeaver.ini编辑窗口末行添加(绝对路径)：<br>“-vm”<br>“-javaagent”</li><li>启动DBeaverEE即可。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 工具推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongoDB数据库查看工具</title>
      <link href="/2021/10/08/mongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/10/08/mongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>支持MAC，不确定是否支持Win</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>MongoDB Compass</li></ul><p>下载地址:<a href="https://www.mongodb.com/try/download/compass">https://www.mongodb.com/try/download/compass</a></p><ul><li>Robo 3T (这个下载安装挺简单的)</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工具推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql数据库查看工具</title>
      <link href="/2021/10/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/10/08/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>Sequel Pro</li></ul><p>这个仅支持Mac端，不过查询效率比navicat-premium要快，据说有特别优化加速。</p><ul><li>navicat-premium</li></ul><p>这个显示的sql执行时间更为接近真实场景。</p><p>下载地址：<a href="https://macwk.com/soft/navicat-premium">https://macwk.com/soft/navicat-premium</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAW API接口调试</title>
      <link href="/2021/10/08/PAW-API%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95/"/>
      <url>/2021/10/08/PAW-API%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>PAW一款类似postman的接口调试工具，curl导入效果感觉比postman要好，另外也有请求的多种代码方式源码。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本文提供的下载链接仅支持Mac</p><h2 id="下载安装链接-破解版"><a href="#下载安装链接-破解版" class="headerlink" title="下载安装链接(破解版)"></a>下载安装链接(破解版)</h2><p><a href="https://macwk.com/soft/paw">https://macwk.com/soft/paw</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO包管理的前世今生</title>
      <link href="/2021/10/08/GO%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2021/10/08/GO%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="早期的GO包管理-了解"><a href="#早期的GO包管理-了解" class="headerlink" title="早期的GO包管理(了解)"></a>早期的GO包管理(了解)</h2><p>早期根本没有所谓的包管理，项目依赖一塌糊涂。那么这样会出现什么问题？</p><blockquote><p>在没有包管理方案之前，项目依赖于 GOPATH，带来一些不便之处</p></blockquote><ul><li>多项目难以管理。试想一下，A 项目和 B 项目 同时依赖于一个 C 项目，但是依赖于 C 项目的不同版本，如何解决，只能通过多 GOPATH 设置。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go命令依赖一个重要的环境变量：$GOPATH</span><br><span class="line">GOPATH允许多个目录，当有多个目录时，请注意分隔符，多个目录的时候Windows是分号;，Linux系统是冒号:</span><br><span class="line">[设置Golang的GOPATH](https://blog.csdn.net/chenjh213/article/details/51381024)</span><br></pre></td></tr></table></figure><ul><li><p>项目的依赖只能够手动 go get 下载到 GOPATH 中，如果换一台服务器开发项目，光是包依赖都得弄半天。</p></li><li><p>如果是本地想搭建对应的项目，还无法知道之前包的版本，只能通过当初项目创建时间进行<code>git tag</code>切换对应版本。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git tag #展示全部tag</span><br><span class="line">git checkout  release-v1.0.0 #切换到tag分支</span><br><span class="line"></span><br><span class="line">无关-记录</span><br><span class="line">git tag release-v1.0.1 #打上tag</span><br><span class="line">git push --tag #推送</span><br></pre></td></tr></table></figure><blockquote><p>一些解决方案</p></blockquote><ul><li><p>godep，glide，go verdor 这些都是曾经出现过的包管理解决方案。</p></li><li><p>将所有依赖包都上传到一个公共的线上文件夹(类似vendor)，然后从上面直接拷贝。</p></li></ul><h2 id="现在的GO包管理-go版本-gt-x3D-1-11"><a href="#现在的GO包管理-go版本-gt-x3D-1-11" class="headerlink" title="现在的GO包管理(go版本 &gt;&#x3D; 1.11)"></a>现在的GO包管理(go版本 &gt;&#x3D; 1.11)</h2><p>Go.mod是 <strong>Golang1.11版本</strong> 新引入的官方包管理工具用于解决之前没有地方记录依赖包具体版本的问题。</p><p><em>前导</em></p><p>Go.mod其实就是一个Modules官方定义为：</p><p>Modules是相关Go包的集合，是源代码交换和版本控制的单元。go命令直接支持使用Modules，包括记录和解析对其他模块的依赖性。Modules替换旧的基于GOPATH的方法，来指定使用哪些源文件。</p><p>Modules和传统的GOPATH不同，不需要包含例如src，bin这样的子目录，一个源代码目录甚至是空目录都可以作为Modules，只要其中包含有go.mod文件。</p><p><strong>go mod的使用：</strong></p><p>一个很关键的地方在于环境变量GO111MODULE的设置,GO111MODULE有三个值：off, on和auto（默认值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或GOPATH模式来查找。</span><br><span class="line"></span><br><span class="line">2.GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。</span><br><span class="line"></span><br><span class="line">3.GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。</span><br><span class="line">这种情况下可以分为两种情形：</span><br><span class="line">当前目录在GOPATH/src之外且该目录包含go.mod文件</span><br><span class="line">当前文件在包含go.mod文件的目录下面。</span><br><span class="line">Go mod 的命令使用help查看</span><br></pre></td></tr></table></figure><p>如何在项目中使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#cd xxx //进入项目</span><br><span class="line">#go mod init  //初始化项目</span><br><span class="line">#ps</span><br><span class="line">在当前目录下生成一个go.mod文件，通过这个文件管理包</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：除了go.mod之外，go命令还维护一个名为go.sum的文件，其中包含特定模块版本内容的预期加密哈希。go命令使用go.sum文件确保这些模块的未来下载检索与第一次下载相同的位，以确保项目所依赖的模块不会出现意外更改，无论是出于恶意、意外还是其他原因。 <strong>go.mod和go.sum都应检入版本控制</strong> 。go.sum 不需要手工维护，所以可以不用太关注。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目子目录里是不需要init的，所有的子目录里的依赖都会组织在根目录的go.mod文件里</span><br></pre></td></tr></table></figure><p><strong>当依赖第三方包时:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 最初是go get 拉取，而使用go mod，直接go run 或go build 即可！</span><br><span class="line">例如：go get utils/iGong@v1.3.5</span><br><span class="line">不过，有了go mod后，只要项目 运行 或 创建二进制文件 就会自动拉取依赖。</span><br><span class="line"></span><br><span class="line">- go 会自动查找代码中的包，下载依赖包，并且把具体的依赖关系和版本写入到go.mod和go.sum文件中。</span><br><span class="line"></span><br><span class="line">- 依赖的第三方包被下载到了$GOPATH/pkg/mod路径下。</span><br></pre></td></tr></table></figure><p><strong>依赖包的版本控制：</strong></p><p>GOPATH&#x2F;pkg&#x2F;mod里可以保存相同包的<strong>不同版本</strong>。<br>go.mod中可指定下载包的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果在go.mod中没有指定，go命令会自动下载最新版本。</span><br><span class="line">如果在go.mod用require语句指定包和版本 ，go命令会根据指定的路径和版本下载包。</span><br><span class="line">当然，对于某些缺失的包，可以用replace指定代替包。</span><br><span class="line">指定版本时可以用latest，这样它会自动下载指定包的最新版本,项目也可以放在$GOPATH/src下。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module app #项目名</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">gorm.io/driver/mysql v1.1.2 // indirect</span><br><span class="line">gorm.io/gorm v1.21.15 // indirect</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">replace github.com/qiniu/bytes =&gt; gitlab.airdroid.com/zhuoh/bytes v0.0.0-20191012100200-92558a444c07</span><br></pre></td></tr></table></figure><h2 id="参考原文"><a href="#参考原文" class="headerlink" title="参考原文"></a>参考原文</h2><p><a href="https://blog.csdn.net/jkwanga/article/details/106288345">原文链接</a><br><a href="https://www.jianshu.com/p/d04b36fbdcd6#comments">原文链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-部署gitlab</title>
      <link href="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/"/>
      <url>/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前提条件"><a href="#一、前提条件" class="headerlink" title="一、前提条件"></a>一、前提条件</h3><p>1.存在docker<br>2.服务器可以联网（外网）<br>3.服务器内存至少4G（内存不够会出现502错误）</p><p>内存不足502错误如下图所示：</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g1.png"></p><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><p>安装环境:Centos7</p><p>1.查找GitLab镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search gitlab</span><br></pre></td></tr></table></figure><p>2.拉取gitlab docker镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><p>3.运行GitLab并运行容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-itd \</span><br><span class="line">-p 9980:80 \</span><br><span class="line">-p 9922:22 \</span><br><span class="line">-v /usr/local/gitlab-test/etc:/etc/gitlab \</span><br><span class="line">-v /usr/local/gitlab-test/log:/var/log/gitlab \</span><br><span class="line">-v /usr/local/gitlab-test/opt:/var/opt/gitlab \</span><br><span class="line">--restart always \</span><br><span class="line">--privileged=true \</span><br><span class="line">--name gitlab-test \</span><br><span class="line">gitlab/gitlab-ce</span><br></pre></td></tr></table></figure><p>成功会返回的容器ID哦！！<br>　　<br>命令解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-i 以交互模式运行容器，通常与 -t 同时使用命令解释：</span><br><span class="line"></span><br><span class="line">-t 为容器重新分配一个伪输入终端，通常与 -i 同时使用</span><br><span class="line"></span><br><span class="line">-d 后台运行容器，并返回容器ID</span><br><span class="line"></span><br><span class="line">-p 9980:80 将容器内80端口映射至宿主机9980端口，这是访问gitlab的端口</span><br><span class="line"></span><br><span class="line">-p 9922:22 将容器内22端口映射至宿主机9922端口，这是访问ssh的端口</span><br><span class="line"></span><br><span class="line">-v /usr/local/gitlab-test/etc:/etc/gitlab 将容器/etc/gitlab目录挂载到宿主机/usr/local/gitlab-test/etc目录下，若宿主机内此目录不存在将会自动创建，其他两个挂载同这个一样</span><br><span class="line"></span><br><span class="line">--restart always 容器自启动</span><br><span class="line"></span><br><span class="line">--privileged=true 让容器获取宿主机root权限</span><br><span class="line"></span><br><span class="line">--name gitlab-test 设置容器名称为gitlab-test</span><br><span class="line"></span><br><span class="line">gitlab/gitlab-ce 镜像的名称，这里也可以写镜像ID</span><br></pre></td></tr></table></figure><p><strong>重点：接下来的配置请在容器内进行修改，不要在挂载到宿主机的文件上进行修改。否则可能出现配置更新不到容器内，或者是不能即时更新到容器内，导致gitlab启动成功，但是无法访问</strong></p><p>4.进入容器内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it gitlab-test /bin/bash</span><br></pre></td></tr></table></figure><p>5.修改gitlab.rb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 打开文件</span><br><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"> </span><br><span class="line"># 这个文件是全注释掉了的，所以直接在首行添加如下配置</span><br><span class="line">  </span><br><span class="line"># gitlab访问地址，可以写域名。如果端口不写的话默认为80端口 （图片上拼写错误，正确的是external_url）</span><br><span class="line">external_url &#x27;http://192.168.201.5:9980&#x27;</span><br><span class="line"># ssh主机ip</span><br><span class="line">gitlab_rails[&#x27;gitlab_ssh_host&#x27;] = &#x27;192.168.201.5&#x27;</span><br><span class="line"># ssh连接端口</span><br><span class="line">gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 9922</span><br></pre></td></tr></table></figure><p>6.修改gitlab.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 打开文件</span><br><span class="line">vi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</span><br></pre></td></tr></table></figure><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 配置解释：</span><br><span class="line"> </span><br><span class="line"># host：访问的IP  192.168.201.5</span><br><span class="line"> </span><br><span class="line"># port：访问的端口  9980</span><br><span class="line"> </span><br><span class="line"># 以上两个和gitlab.rb内external_url的配置保持一致</span><br><span class="line"> </span><br><span class="line"># ssh_host：ssh主机ip，和gitlab.rb内gitlab_rails[&#x27;gitlab_ssh_host&#x27;]保持一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 配置二：找到gitlab_shell标签下的ssh_port，将其修改为9922</span><br><span class="line">#（和gitlab.rb内gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] 保持一致）</span><br></pre></td></tr></table></figure><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g3.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 保存并退出:wq</span><br></pre></td></tr></table></figure><p>7.让修改后的配置生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>8.重启gitlab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>9.退出容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p>10.在游览器输入如下地址，访问gitlab（eaxternal_url配置的就是这个）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:192.168.201.5:9980</span><br></pre></td></tr></table></figure><p>如果访问不成功的话：</p><p>（1）   进入容器查看gitlab.rb和gitlab.yml文件是否配置成功</p><p>（2）   查看防火墙是否开放9980、9922端口</p><p>11.依然访问不成功！！</p><p>确认防火墙firewall 和 iptables 都没有阻止端口。gitlab也运行成功，但是无法访问！！</p><p>查看端口,确实有监听9980和9922端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lntp</span><br></pre></td></tr></table></figure><p>但是telnet还是被拒绝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.201.5 9980</span><br></pre></td></tr></table></figure><p>查看了了日志，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f -t  --tail=100 gitlab-test | grep &quot;failed&quot;</span><br><span class="line"></span><br><span class="line">021/09/27 16:47:03 [crit] 929#0: *54 connect() to unix:/var/opt/gitlab/gitlab-workhorse/sockets/socket failed (2: No such file or directory) while connecting</span><br><span class="line">to upstream, client: 127.0.0.1, server: 756dc32e9be4, request: &quot;GET /help HTTP/1.1&quot;, upstream: &quot;http://unix:/var/opt/gitlab/gitlab-work</span><br><span class="line"></span><br><span class="line">实时查看gitlab的输出日志(也能找到上面错误)</span><br><span class="line">gitlab-ctl tail</span><br><span class="line"></span><br><span class="line">查看gitlab当前的启动状态(正常)</span><br><span class="line">gitlab-ctl status</span><br></pre></td></tr></table></figure><p>于是网上搜了方法,docker 镜像启动成功但是无法访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">vi /etc/sysctl.conf 或者</span><br><span class="line"></span><br><span class="line">vi /usr/lib/sysctl.d/00-system.conf 添加如下代码： net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line">重启network服务</span><br><span class="line"></span><br><span class="line">systemctl restart network 查看是否修改成功</span><br><span class="line"></span><br><span class="line">sysctl net.ipv4.ip_forward 如果返回为“net.ipv4.ip_forward = 1”则表示成功了</span><br></pre></td></tr></table></figure><p>但因为原本就是”net.ipv4.ip_forward &#x3D; 1”，所以也不是这个原因。</p><p>还提升了虚拟机内存，但同样无法访问。</p><p>最后，发现了gitlab对8080端口是有需求的，所以kill -9相关进程后，发现可以访问了(还是要等待一段时间)。</p><p>12.第一次访问默认是root账户，会需要修改密码（密码至少8位数，出现如下界面就基本上部署成功了）</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g4.png"></p><p>13.输入新密码后进行登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root/gitlab123456</span><br></pre></td></tr></table></figure><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g5.png"></p><p>14.登录后界面如下图，创建一个新项目</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g6.png"></p><p>15.输入信息，创建项目</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g7.png"></p><p>16.检查这里两处的ip的端口是否是你配置的</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g8.png"></p><p>如果这里两处的端口和ip和配置的不一样，再次进入容器检查gitlab.yml文件</p><p>如下图显示：</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g9.png"></p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g10.png"></p><p>若不一样，将其修改为你的配置，然后:wq，再进行下面的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>17.安装到此结束</p><h3 id="三、关闭用户注册"><a href="#三、关闭用户注册" class="headerlink" title="三、关闭用户注册"></a>三、关闭用户注册</h3><p>1.使用root用户登录gitlab</p><p>2.点击【Admin Area】</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g11.png"></p><p>3.点击【Settings】</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g12.png"></p><p>4.点击Sign-in restrictions这一栏的【Expand】</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g13.png"></p><p>5.取消勾选</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g14.png"></p><p>6.往下滑动，找到保存按钮，点击保存</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g15.png"></p><p>7.进入登录界面，发现注册的窗口已经消失了</p><p><img src="/2021/10/02/Docker-%E9%83%A8%E7%BD%B2gitlab/d_g16.png"></p><h3 id="四、邮件配置"><a href="#四、邮件配置" class="headerlink" title="四、邮件配置"></a>四、邮件配置</h3><h3 id="五、自动备份配置"><a href="#五、自动备份配置" class="headerlink" title="五、自动备份配置"></a>五、自动备份配置</h3><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p><a href="https://www.cnblogs.com/diaomina/p/12830449.html">docker部署gitlab</a></p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>虽然，这几篇文章没有真正帮助到点，但也给了启迪。让我关掉已占用的8080端口，在此附上链接。</p><p><a href="https://www.cnblogs.com/zuxing/articles/9329152.html">docker安装配置gitlab详细过程</a></p><p><a href="https://blog.csdn.net/xiayuandongcn/article/details/119871356">centos7 gitlab14搭建完成后，无法访问的问题处理（“error“:“badgateway: failed to receive response: dial unix &#x2F;var&#x2F;opt）</a> 这篇有帮助，但未实践成功。因为直接kill了8080端口占用进程。</p><p><a href="https://blog.csdn.net/wangxicoding/article/details/43738137">我所遇到的GitLab 502问题的解决</a></p><p>比较实用的几篇</p><p><a href="https://www.cnblogs.com/kofsony/p/11103852.html">docker启动,重启,关闭命令</a></p><p><a href="https://www.cnblogs.com/kreo/p/4368811.html">CentOS7安装iptables防火墙</a></p><p><a href="https://www.cnblogs.com/zl1991/p/10531726.html">docker 端口映射 及外部无法访问问题</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门教程</title>
      <link href="/2021/10/02/Docker-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
      <url>/2021/10/02/Docker-%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>此处在Centos7进行安装，可以使用以下命令查看CentOS版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><p>在 CentOS 7安装docker要求系统为64位、系统内核版本为 3.10 以上，可以使用以下命令查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h3 id="用yum源安装"><a href="#用yum源安装" class="headerlink" title="用yum源安装"></a>用yum源安装</h3><p><strong>查看是否已安装docker列表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep docker</span><br></pre></td></tr></table></figure><p><strong>安装docker</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/kingsonfu/p/11576797.html">linux 安装docker</a></p><h3 id="查找docker安装路径"><a href="#查找docker安装路径" class="headerlink" title="查找docker安装路径"></a>查找docker安装路径</h3><p>Linux系统下查找安装包所在目录的方法,rpm查找安装包路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Linux rpm 命令用于管理套件</span><br><span class="line">参数说明：</span><br><span class="line">-a 　查询所有套件。</span><br><span class="line">-l 　显示套件的文件列表。</span><br><span class="line">-q 　使用询问模式，当遇到任何问题时，rpm指令会先询问用户</span><br><span class="line"></span><br><span class="line">rpm -qa | grep docker</span><br><span class="line"></span><br><span class="line">rpm -ql docker-ce-19.03.13-3.el7.x86_64</span><br><span class="line"></span><br><span class="line">which</span><br><span class="line">使用指令&quot;which&quot;查看&quot;nginx&quot;的绝对路径，输入如下命令</span><br><span class="line">which nginx</span><br><span class="line"></span><br><span class="line">whereis</span><br><span class="line">使用 whereis 命令，能够方便的定位到文件系统中可执行文件的位置</span><br><span class="line">whereis nginx</span><br></pre></td></tr></table></figure><h3 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker version 或者# docker info</span><br></pre></td></tr></table></figure><h3 id="Docker-需要用户具有-sudo-权限，为了避免每次命令都输入sudo，可以把用户加入-Docker-用户组"><a href="#Docker-需要用户具有-sudo-权限，为了避免每次命令都输入sudo，可以把用户加入-Docker-用户组" class="headerlink" title="Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组"></a>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><h3 id="Docker-运行命令"><a href="#Docker-运行命令" class="headerlink" title="Docker 运行命令"></a>Docker 运行命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl 命令的用法</span><br><span class="line">$ sudo systemctl start docker </span><br></pre></td></tr></table></figure><h2 id="image文件"><a href="#image文件" class="headerlink" title="image文件"></a>image文件</h2><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong></p><p>只有通过这个文件，才能生成 Docker 容器。<strong>image 文件可以看作是容器的模板</strong>。Docker 根据 image 文件<strong>生成</strong>容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机的所有 image 文件。</span><br><span class="line">$ docker image ls# 删除 image 文件$ docker image rm [imageName]</span><br></pre></td></tr></table></figure><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><blockquote><p>将 image 文件从仓库抓取到本地</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull library/hello-world</span><br></pre></td></tr></table></figure><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 <strong>Docker 官方提供</strong> 的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，<strong>可以省略</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull hello-world</span><br></pre></td></tr></table></figure><blockquote><p>查看 image 文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure><blockquote><p>运行这个 image 文件生成容器实例并运行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br></pre></td></tr></table></figure><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><blockquote><p>手动终止容器运行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container kill [containID]</span><br></pre></td></tr></table></figure><h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机正在运行的容器</span><br><span class="line">$ docker container ls</span><br><span class="line">或</span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"># 列出本机所有容器，包括终止运行的容器</span><br><span class="line">$ docker container ls --all</span><br></pre></td></tr></table></figure><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href="https://docs.docker.com/engine/reference/commandline/container_rm/"><code>docker container rm</code></a>命令删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">rm</span> [containerID]</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h2><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p><h2 id="实例：制作自己的-Docker-容器"><a href="#实例：制作自己的-Docker-容器" class="headerlink" title="实例：制作自己的 Docker 容器"></a>实例：制作自己的 Docker 容器</h2><p>这部分内容就不做抄录了，附上参考和转载文章地址 <a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a> 和 <a href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">Docker 微服务教程</a>,</p><h2 id="image-仓库的镜像网址"><a href="#image-仓库的镜像网址" class="headerlink" title="image 仓库的镜像网址"></a>image 仓库的镜像网址</h2><p>本教程需要从仓库下载 image 文件，但是国内访问 Docker 的官方仓库很慢，还经常断线，所以要把仓库网址改成国内的镜像站。这里推荐使用官方镜像 registry.docker-cn.com 。下面是我的 Debian 系统的默认仓库修改方法，其他系统的修改方法参考官方文档。</p><p>打开&#x2F;etc&#x2F;default&#x2F;docker文件（需要sudo权限），在文件的底部加上一行。</p><p>DOCKER_OPTS&#x3D;”–registry-mirror&#x3D;<a href="https://registry.docker-cn.com&quot;/">https://registry.docker-cn.com&quot;</a><br>然后，重启 Docker 服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure><p>现在就会自动从镜像仓库下载 image 文件了。</p><h2 id="github镜像"><a href="#github镜像" class="headerlink" title="github镜像"></a>github镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hub.fastgit.org/</span><br></pre></td></tr></table></figure><p><strong>原文链接：</strong></p><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于git撤回内容的思考</title>
      <link href="/2021/09/01/%E5%85%B3%E4%BA%8Egit%E6%92%A4%E5%9B%9E%E5%86%85%E5%AE%B9%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2021/09/01/%E5%85%B3%E4%BA%8Egit%E6%92%A4%E5%9B%9E%E5%86%85%E5%AE%B9%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><p>如果是在本地就直接用Reset</p><p><a href="https://www.jianshu.com/p/c2ec5f06cf1a">Git Reset 三种模式</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限制ip接口案例</title>
      <link href="/2021/09/01/%E9%99%90%E5%88%B6ip%E6%8E%A5%E5%8F%A3%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/09/01/%E9%99%90%E5%88%B6ip%E6%8E%A5%E5%8F%A3%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要开细节类"><a href="#为什么要开细节类" class="headerlink" title="为什么要开细节类"></a>为什么要开细节类</h2><p>因为有很多东西，很细微，但又很实用。就会放在细节类。该类的目的是做个记录，既然简单。</p><h2 id="限制ip接口案例"><a href="#限制ip接口案例" class="headerlink" title="限制ip接口案例"></a>限制ip接口案例</h2><blockquote><p>场景</p></blockquote><p>需要针对相同ip用户每分访问接口次数的做限制，防止用户恶意刷。</p><blockquote><p>代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口 ip 限制</span><br><span class="line"> * @param $miniutes 分钟数</span><br><span class="line"> * @param $times 次数</span><br><span class="line"> * @param $api 接口唯一标识</span><br><span class="line"> * @return bool</span><br><span class="line"> */</span><br><span class="line">public function apiIpLimit($miniutes, $times, $api)</span><br><span class="line">&#123;</span><br><span class="line">    $ip = Request::getClientIP(); //获取用户ip</span><br><span class="line"></span><br><span class="line">    if ($ip) &#123;</span><br><span class="line">        $key = $api . &quot;_&quot; . $ip;</span><br><span class="line"></span><br><span class="line">        $num = Yii::$app-&gt;cookie-&gt;get($key);</span><br><span class="line">        $num = $num ? $num + 1 : 1; //请求次数加1</span><br><span class="line">        if ($num &gt; $times) &#123;</span><br><span class="line">            Yii::getLogger()-&gt;log($key . &quot; exceed limit&quot;, Logger::LEVEL_ERROR);</span><br><span class="line">            return false; //超过限制次数直接返回，不重置过期时间</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Yii::$app-&gt;cookie-&gt;set($key, $num, $miniutes * 60); //未超过限制次数，更新访问次数，并重置过期时间为一分钟</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><blockquote><p>情景</p></blockquote><p>假设每分钟限制8次请求</p><blockquote><p>代码逻辑是否符合需求</p></blockquote><p>上面的代码案例并不是完全依照<code>每分钟限制8次请求</code>逻辑处理，因为有重置过期时间。</p><p>假设第6，7，8次请求都间隔了40s。按逻辑，第6次和第8次中间间隔了80s，超过一分钟了，但因为访问接口，未超过限制次数时会重置<code>过期时间</code>为60s的因素，第6次访问和第8次访问被累加在同一个次数累计中。</p><blockquote><p>代码合理性</p></blockquote><p>从合理性上，我觉得是合理的。但逻辑解释应该是<strong>相同ip距离上一次访问时间不超过一分钟，计入次数累计，当次数累计超过限制次数将会返回错误，时间1min</strong></p><p>当然，如果要按目前逻辑实现也很简单，可以存储值<code>num_day</code>(累计次数+当天日期<code>(最小单位:天)</code>)，然后重置的时间设置为<code>当前时间戳-第一次的时间戳</code>。</p><blockquote><p>优化点</p></blockquote><p>首先ip这块用户可以通过vpn等手段切换不同ip。</p><p>其次，限制次数是设置在cookie用户是可以删除的。</p><p>建议：限制用户每天可以请求多少次，记录在redis之类的服务端缓存。</p><h2 id="限制用户每天可以请求多少次"><a href="#限制用户每天可以请求多少次" class="headerlink" title="限制用户每天可以请求多少次"></a>限制用户每天可以请求多少次</h2><blockquote><p>检验</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 邀请邮件 校验: 每天(utc时区)限制50封</span><br><span class="line">if ($this-&gt;getApiRequestLimitByDay(50, &#x27;bizInviteEmail&#x27;) === false) &#123;</span><br><span class="line">    Response::echoResult(ErrCode::$ACCOUNT_LIMIT_ERR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>累计次数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;setApiRequestLimitByDay(&#x27;bizInviteEmail&#x27;, $accountId); //发送邮件后更新用户当天发邮件次数</span><br></pre></td></tr></table></figure><blockquote><p>方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取接口是否超出每日访问次数限制</span><br><span class="line"> * @param $times 次数</span><br><span class="line"> * @param $api 限制内容唯一标识</span><br><span class="line"> * @param string $accountId 用户主账号id</span><br><span class="line"> * @return bool</span><br><span class="line"> */</span><br><span class="line">public function getApiRequestLimitByDay($times, $api, $accountId = &quot;&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    if(empty($accountId)) &#123;</span><br><span class="line">        $accountId = \Yii::$app-&gt;bizUser-&gt;accountId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($accountId) &#123;</span><br><span class="line">        $day = date(&#x27;Y_m_d&#x27;,time());</span><br><span class="line">        $key = $api . &quot;_&quot; . $accountId . &quot;_&quot; . $day;</span><br><span class="line"></span><br><span class="line">        $redis = Factory::getUserRedisClient();</span><br><span class="line">        $num = $redis-&gt;get($key);</span><br><span class="line">        $num = $num ? $num + 1 : 1;</span><br><span class="line"></span><br><span class="line">        if ($num &gt; $times) &#123;</span><br><span class="line">            Yii::getLogger()-&gt;log($key . &quot; exceed limit&quot;, Logger::LEVEL_ERROR);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 更新(累加)接口每日访问次数</span><br><span class="line"> * @param $api 限制内容唯一标识</span><br><span class="line"> * @param string $accountId 用户主账号id</span><br><span class="line"> */</span><br><span class="line">public function setApiRequestLimitByDay($api, $accountId = &quot;&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    if(empty($accountId)) &#123;</span><br><span class="line">        $accountId = \Yii::$app-&gt;bizUser-&gt;accountId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($accountId) &#123;</span><br><span class="line">        $day = date(&#x27;Y_m_d&#x27;,time());</span><br><span class="line">        $key = $api . &quot;_&quot; . $accountId . &quot;_&quot; . $day;</span><br><span class="line"></span><br><span class="line">        $redis = Factory::getUserRedisClient();</span><br><span class="line">        $num = $redis-&gt;get($key);</span><br><span class="line">        $num = $num ? $num + 1 : 1;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            $redis-&gt;setex($key, 86400, $num); //保存一天后过期</span><br><span class="line">        &#125; catch (\Exception $e) &#123;</span><br><span class="line">            LogService::logError(&quot;set $ownerId $key exception : &quot; . $e-&gt;getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 细节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用操作命令大全</title>
      <link href="/2021/08/17/Docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2021/08/17/Docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Linux  Centos7</p><h2 id="docker进程相关命令"><a href="#docker进程相关命令" class="headerlink" title="docker进程相关命令"></a>docker进程相关命令</h2><ul><li><code>systemctl start docker</code> #启动docker服务</li><li><code>systemctl stop docker</code> #停止docker服务</li><li><code>systemctl restart docker</code>#重启docker服务</li><li><code>systemctl status docker</code> #查看docker服务状态</li><li><code>systemctl enable docker</code>#设置开机启动服务</li></ul><h2 id="docker容器管理命令"><a href="#docker容器管理命令" class="headerlink" title="docker容器管理命令"></a>docker容器管理命令</h2><p><code>docker run -d --name &#123;your_name&#125; &#123;image_name&#125;</code> # 运行容器</p><blockquote><p>参数说明：</p><p>-i：以交互模式运行容器，通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</p><p>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。</p><p>-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。</p><p>-it 创建的容器一般称为交互式容器；</p><p>-id 创建的容器一般称为守护式容器。</p><p>–name：为创建的容器命名。</p><p>-p：指定容器的端口，格式为：主机(宿主)端口:容器端口 </p><p>-P(大写): 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</p><p>–volume , -v: 绑定一个卷,格式:宿主机目录&#x2F;文件:容器内目录&#x2F;文件</p><p>​                       目录必须是绝对路径,如果目录不存在，会自动创建,可以挂载多个数据卷。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line"></span><br><span class="line">绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</span><br><span class="line">$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br></pre></td></tr></table></figure><ul><li><code>docker ps</code> # 查看正在运行的容器</li><li><code>docker ps -s -a</code> #查看当前所有容器</li><li><code>docker stop &#123;容器ID&#125;</code> #停止容器</li><li><code>docker restart &#123;容器ID&#125;</code> #重启容器</li><li><code>docker kill &#123;容器ID&#125;</code> #杀死容器</li><li><code>docker rm -f &#123;容器ID&#125;</code> #删除已经停止的容器(这个会彻底释放内存)</li></ul><p><strong>如果容器是运行状态则删除失败，需要停止容器才能删除。</strong></p><h2 id="docker镜像管理命令"><a href="#docker镜像管理命令" class="headerlink" title="docker镜像管理命令"></a>docker镜像管理命令</h2><ul><li><p><code>docker images</code> #查看当前机器的所有镜像</p><blockquote><p>参数：</p><p>-a&#x2F;–all 列出所有镜像</p><p>-q&#x2F;–quiet 只显示镜像的id</p></blockquote></li><li><p><code>docker images –q</code> # 查看所用镜像的id</p></li><li><p><code>docker search &#123;镜像名称&#125;</code> #搜索镜像，网络中查找需要的镜像</p><p><code>$docker search redis</code></p><p><strong>查找stars大于3000的镜像</strong>：<code>docker search mysql --filter=stars=3000</code></p></li><li><p><code>docker pull &#123;镜像名称&#125;[:tag]</code> #从Docker仓库拉取镜像，名称:版本号</p></li></ul><p>​     <code>$docker pull mysql</code> 或<code>$docker pull mysql:5.7</code> </p><ul><li><p><code>docker push &#123;镜像名称&#125;</code> #推送镜像</p></li><li><p><code>docker rmi [-f] &#123;镜像名称/镜像id&#125;</code> #删除本地机器的镜像</p></li><li><p><code>docker rmi [-f]  &#123;镜像id&#125; &#123;镜像id&#125; &#123;镜像id&#125;</code> #删除多个本地机器的镜像</p></li><li><p><code>docker rmi [-f] docker images -q</code> #删除所有本地镜像</p></li><li><p><code>docker tag 镜像名称:tag 镜像名称:tag</code> #为一个镜像打tag</p><blockquote><p>将镜像ubuntu:15.10标记为 runoob&#x2F;ubuntu:v3 镜像</p></blockquote><p><code>docker tag ubuntu:15.10 runoob/ubuntu:v3</code></p><p><strong>查看:</strong> <code>docker images runoob/ubuntu:v3</code></p></li><li><p><code>docker save &#123;image_name&#125; &gt; &#123;new_image_name&#125;.tar</code> #镜像打包成一个tar包</p></li><li><p><code>docker load &lt; &#123;image_name&#125;.tar</code> #解压一个镜像tar包</p></li></ul><h2 id="查看日志信息"><a href="#查看日志信息" class="headerlink" title="查看日志信息"></a>查看日志信息</h2><ul><li><code>docker logs -f &#123;容器ID&#125;</code>  #查看容器日志</li><li><code>docker info</code> #查看docker服务的信息</li><li><code>docker inspect &#123;容器ID&#125;</code> # 获取镜像的元信息，详细信息</li></ul><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p><code>$ docker top f42ae22e4b72</code></p><h2 id="与容器交互的命令"><a href="#与容器交互的命令" class="headerlink" title="与容器交互的命令"></a>与容器交互的命令</h2><h3 id="进入正在运行的容器"><a href="#进入正在运行的容器" class="headerlink" title="进入正在运行的容器"></a>进入正在运行的容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器ID或者容器名 /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>exec的意思是在容器中运行⼀个命令。&#x2F;bin&#x2F;bash是固有写法，作用是因为docker后台必须运行一个进程，否则容器就会退出，在这里表示启动容器后启动 bash。</p><p>-d :分离模式: 在后台运行</p><p>-i :即使没有附加也保持STDIN 打开</p><p>-t :分配一个伪终端</p></blockquote><blockquote><p>退出容器</p></blockquote><p><code>exit</code> #退出也关闭容器;</p><p><code>Ctrl+P+Q</code> #退出不关闭容器</p><p><strong>拷贝文件</strong></p><p><code>docker cp 主机文件路径 容器ID或容器名:容器路径</code> #宿主机文件拷贝到容器中</p><p><code>docker cp 容器ID或容器名:容器路径 主机文件路径</code> #容器文件拷贝到宿主机中</p><p><strong>原文链接：</strong></p><p><a href="https://juejin.cn/post/6993582707582173198">docker命令记不住？docker常用操作命令大全</a></p><p><a href="https://juejin.cn/post/6996126578048499743">Docker常用命令</a></p><p><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>charles手机端捕获数据</title>
      <link href="/2021/08/17/charles%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%8D%95%E8%8E%B7%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/08/17/charles%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%8D%95%E8%8E%B7%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>推荐一款自己常用的捕获手机端数据工具:<strong>charles</strong></p><p>注意:关于安卓7.0版本以上charles无法抓取https包的问题,这个因为测试都是公司的包，所以安卓开发那边会做相应处理打包，就不会出现问题了。</p><p><a href="https://blog.csdn.net/lovelygirlyuzhu/article/details/109645152">关于Charles的安装，Charles给手机链接代理，安装证书，安卓手机抓包的连接，以及配置</a> 这篇文章写得很不错的。</p><blockquote><p>常用的点</p></blockquote><p>在处理好PC端的charles的下载，安装，证书之类后。</p><p>手机连接与电脑<strong>同一网络下</strong>的WIFI,手动设置<code>代理</code>，主机名<code>charles:Help-&gt;Local IP Addresses</code>,端口名<code>charles:Proxy-&gt;Proxy Settings-&gt;Port</code>。</p><p>连接成功后，其实就可以捕获数据了。但是https的数据会显示错误，这时候就需要下载证书了。</p><p>手机浏览器下载证书链接:<a href="http://chls.pro/ssl,%E4%B8%8B%E8%BD%BD%E5%AE%8C%E5%90%8E%E3%80%82%E8%AE%A9%E6%89%8B%E6%9C%BA%E4%BF%A1%E4%BB%BB%E8%AF%81%E4%B9%A6%EF%BC%8C%E4%BE%8B%E5%A6%82:&quot;%E6%8C%87%E7%BA%B9%E4%B8%8E%E5%AF%86%E7%A0%81-%E5%85%B6%E4%BB%96%E5%AE%89%E8%A3%85%E9%80%89%E9%A1%B9-%E4%BB%8E%E5%AD%98%E5%82%A8%E8%A3%85%E7%BD%AE%E5%AE%89%E8%A3%85&quot;%E6%93%8D%E4%BD%9C%E4%BF%A1%E4%BB%BB%EF%BC%8C%E5%BD%93%E7%84%B6%E4%B8%8D%E5%90%8C%E6%89%8B%E6%9C%BA%E6%93%8D%E4%BD%9C%E4%BF%A1%E4%BB%BB%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%8D%E4%B8%80%E5%AE%9A%E7%9B%B8%E5%90%8C%E3%80%82">http://chls.pro/ssl,下载完后。让手机信任证书，例如:&quot;指纹与密码-其他安装选项-从存储装置安装&quot;操作信任，当然不同手机操作信任的路径不一定相同。</a></p><blockquote><p>Charles抓包postman</p></blockquote><p>因为有很多测试再<code>postman</code>上面测试，那么如何让<code>postman</code>上面的数据被charles捕获，看下面这篇文章。</p><p><a href="https://blog.csdn.net/zhongyili_sohu/article/details/87881861">Charles抓包postman</a></p><p>要想postman请求走charles，那么需要手动在postman设置代理，如下图</p><p><img src="/2021/08/17/charles%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%8D%95%E8%8E%B7%E6%95%B0%E6%8D%AE/1.png"></p><blockquote><p>Charles Android 抓包失败(未实践，因为内部有专门可捕捉包)</p></blockquote><p><a href="https://blog.csdn.net/x2584179909/article/details/108376220">app抓不到包之将证书安装到系统证书中</a></p><p><a href="https://blog.csdn.net/mrxiagc/article/details/75329629">Charles Android 抓包失败SSLHandshake: Received fatal alert: certificate_unknown</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 控制结构for循环loop</title>
      <link href="/2021/08/16/Go-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84for%E5%BE%AA%E7%8E%AFloop/"/>
      <url>/2021/08/16/Go-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84for%E5%BE%AA%E7%8E%AFloop/</url>
      
        <content type="html"><![CDATA[<p>for循环是编程语言中一种循环语句，<strong>for 是 Go 语言唯一的循环语句.Go 语言中并没有其他语言比如 C 语言中的 while 和 do while 循环.</strong></p><blockquote><p>for循环</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for initialisation; condition; post &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是典型的 for 循环三个表达式,第一个为初始化表达式或赋值语句;第二个为循环条件判定表达式;第三个为循环变量修正表达式,即此处的 post。</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main  </span><br><span class="line">import &quot;fmt&quot;  </span><br><span class="line">func main() &#123;  </span><br><span class="line">   for a := 0; a &lt; 12; a++ &#123;  </span><br><span class="line">      fmt.Print(a,&quot;\n&quot;)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>&amp;nbsp;</p><blockquote><p>for嵌套</p></blockquote><p>Go 语言允许用户在循环内使用循环.接下来我们将为大家介绍嵌套循环的使用.</p><p>以下实例使用循环嵌套来输出 2 到 100 间的素数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   /* 定义局部变量 */</span><br><span class="line">   var i, j int</span><br><span class="line"></span><br><span class="line">   for i=2; i &lt; 100; i++ &#123;</span><br><span class="line">      for j=2; j &lt;= (i/j); j++ &#123;</span><br><span class="line">         if(i%j==0) &#123;</span><br><span class="line">            break; // 如果发现因子,则不是素数</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(j &gt; (i/j)) &#123;</span><br><span class="line">         fmt.Printf(&quot;%d  是素数\n&quot;, i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>break</p></blockquote><p>break 语句用于在完成正常执行之前突然终止 for 循环,之后程序将会在 for 循环下一行代码开始执行。简单说就是整个for循环都结束了。</p><blockquote><p>continue</p></blockquote><p>continue 语句用来跳出 for 循环中当前循环.在 continue 语句后的所有的 for 循环语句都不会在本次循环中执行.循环体会在一下次循环中继续执行。简单说就是for循环当前对应值的循环体内容终止执行，但for循环会继续匹配下一个值。</p><blockquote><p>goto</p></blockquote><p>Go 语言的 goto 语句可以<strong>无条件地转移到过程中指定的行</strong>.</p><p>goto 语句通常与条件语句配合使用.可用来实现条件转移, 构成循环,跳出循环体等功能.</p><p><strong>但是,在结构化程序设计中一般不主张使用 goto 语句, 以免造成程序流程的混乱,使理解和调试程序都产生困难.</strong></p><p><strong>直接看示例：</strong></p><p>在变量 a 等于 15 的时候跳过本次循环并回到循环的开始语句 LOOP 处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   /* 定义局部变量 */</span><br><span class="line">   var a int = 10</span><br><span class="line"></span><br><span class="line">   /* 循环 */</span><br><span class="line">   LOOP: for a &lt; 20 &#123;</span><br><span class="line">      if a == 15 &#123;</span><br><span class="line">         /* 跳过迭代 */</span><br><span class="line">         a = a + 1</span><br><span class="line">         goto LOOP</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(&quot;a的值为 : %d\n&quot;, a)</span><br><span class="line">      a++     </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">goto 和 LOOP配合使用在for循环中是比较经典的案例。上面的例子，a=a+1后a=15,跳转到LOOP处,for循环条件判断位置进行判断。</span><br><span class="line">结果:</span><br><span class="line">a的值为 : 10</span><br><span class="line">a的值为 : 11</span><br><span class="line">a的值为 : 12</span><br><span class="line">a的值为 : 13</span><br><span class="line">a的值为 : 14</span><br><span class="line">a的值为 : 16</span><br><span class="line">a的值为 : 17</span><br><span class="line">a的值为 : 18</span><br><span class="line">a的值为 : 19</span><br></pre></td></tr></table></figure><p>但是，语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goto label;</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">label: statement;</span><br></pre></td></tr></table></figure><p>说明，LOOP你可以随意变换其他值(比如A、LO…)。下面也是一种使用例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   /* 定义局部变量 */</span><br><span class="line">   var a int = 10</span><br><span class="line"></span><br><span class="line">   /* 循环 */</span><br><span class="line">   for a &lt; 20 &#123;</span><br><span class="line">      if a == 15 &#123;</span><br><span class="line">         /* 跳过迭代 */</span><br><span class="line">         a = a + 1</span><br><span class="line">         goto A</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(&quot;a的值为 : %d\n&quot;, a)</span><br><span class="line">      a++</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   A : fmt.Println(&quot;对，就是你&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a的值为 : 10</span><br><span class="line">a的值为 : 11</span><br><span class="line">a的值为 : 12</span><br><span class="line">a的值为 : 13</span><br><span class="line">a的值为 : 14</span><br><span class="line">对，就是你</span><br><span class="line"></span><br><span class="line">//没错，跳到A执行后，for循环终止了。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GO入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO 控制结构if-else</title>
      <link href="/2021/08/16/GO-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84if-else/"/>
      <url>/2021/08/16/GO-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84if-else/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简单例子:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition1 &#123;</span><br><span class="line">// do something</span><br><span class="line">&#125; else if condition2 &#123;</span><br><span class="line">// do something else</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// catch-all or default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>1.即使当代码块之间只有一条语句时,大括号也不可被省略。</p><p>2.关键字 if 和 else 之后的<strong>左</strong>大括号 <code>&#123;</code> 必须和关键字在同一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if x&#123;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;// 无效的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;nbsp;</p><blockquote><p>使用方式</p></blockquote><p>当 if 结构内有 break,continue,goto 或者 return 语句时,Go 代码的常见写法是省略 else 部分.无论满足哪个条件都会返回 x 或者 y 时,一般使用以下写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if condition &#123;</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">return y</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong> 不要同时在 if-else 结构的两个分支里都使用 return 语句,这将导致编译报错 <code>function ends without a return statement</code>（您可以认为这是一个编译器的 Bug 或者特性）.（ <strong>译者注：该问题已经在 Go 1.1 中被修复或者说改进</strong> ）</p><blockquote><p>一些有用的例子</p></blockquote><p>1.判断一个字符串是否为空：</p><ul><li><code>if str == &quot;&quot; &#123; ... &#125;</code></li><li><code>if len(str) == 0 &#123;...&#125;</code> (个人习惯)</li></ul><p>2.判断运行 Go 程序的操作系统类型,这可以通过常量 <code>runtime.GOOS</code> 来判断.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if runtime.GOOS == &quot;windows&quot; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; else &#123; // Unix-like</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码一般被放在 init() 函数中执行.这儿还有一段示例来演示如何根据操作系统来决定输入结束的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var prompt = &quot;Enter a digit, e.g. 3 &quot;+ &quot;or %s to quit.&quot;</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">    if runtime.GOOS == &quot;windows&quot; &#123;</span><br><span class="line">        prompt = fmt.Sprintf(prompt, &quot;Ctrl+Z, Enter&quot;)</span><br><span class="line">    &#125; else &#123; //Unix-like</span><br><span class="line">        prompt = fmt.Sprintf(prompt, &quot;Ctrl+D&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.函数 <code>Abs()</code> 用于返回一个整型数字的绝对值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func Abs(x int) int &#123;</span><br><span class="line">    if x &lt; 0 &#123;</span><br><span class="line">        return -x</span><br><span class="line">    &#125;</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<code>isGreater</code> 用于比较两个整型数字的大小:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func isGreater(x, y int) bool &#123;</span><br><span class="line">    if x &gt; y &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>if-else包含一个初始化语句</p></blockquote><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val := 10</span><br><span class="line">if val &gt; max &#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以这样写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if val := 10; val &gt; max &#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:<strong>使用简短方式 <code>:=</code> 声明的变量的作用域只存在于 if 结构中</strong>（在 if 结构的<strong>大括号之间</strong>,如果使用 if-else 结构则在 else 代码块中变量也会存在)。 如果<strong>变量在 if 结构之前就已经存在</strong>,那么在 if 结构中,该<strong>变量原来的值会被覆盖</strong>.最简单的解决方案就是<strong>不要在初始化语句中声明变量</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var first int = 10</span><br><span class="line">var cond int</span><br><span class="line"></span><br><span class="line">  //基础款，声明变量赋予好值，再进行if判断</span><br><span class="line">if first &lt;= 0 &#123;</span><br><span class="line">fmt.Printf(&quot;first is less than or equal to 0\n&quot;)</span><br><span class="line">&#125; else if first &gt; 0 &amp;&amp; first &lt; 5 &#123;</span><br><span class="line">fmt.Printf(&quot;first is between 0 and 5\n&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Printf(&quot;first is 5 or greater\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//声明变量，在if判断中，先赋值再判断。这个cond赋予的值会覆盖上面的声明变量。</span><br><span class="line">if cond = 5; cond &gt; 10 &#123;</span><br><span class="line">fmt.Printf(&quot;cond is greater than 10\n&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Printf(&quot;cond is not greater than 10\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(cond) //等于5</span><br><span class="line"></span><br><span class="line">//在if判断中，声明变量赋值再判断。</span><br><span class="line">if cond2 := 5; cond2 &gt; 10 &#123;</span><br><span class="line">fmt.Printf(&quot;cond2 is greater than 10\n&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Printf(&quot;cond2 is not greater than 10\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(cond2) //报错，未声明cond2。因为if中声明的变量的作用域只存在于if结构中。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first is 5 or greater</span><br><span class="line">cond is not greater than 10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GO入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO 包package和import</title>
      <link href="/2021/08/16/GO-%E5%8C%85package%E5%92%8Cimport/"/>
      <url>/2021/08/16/GO-%E5%8C%85package%E5%92%8Cimport/</url>
      
        <content type="html"><![CDATA[<blockquote><p>什么是package</p></blockquote><p>package用于对我们的程序进行*<strong>分类*</strong>,以便易于维护. 每个go文件都属于某个包. 每个Go应用程序必须具有<code>main</code>包。包名称应以小写字母书写. 如果更改并重新编译package,则必须重新编译使用此package的所有代码程序！</p><blockquote><p>Import 别名导入</p></blockquote><p> <code>import mongo &quot;mywebapp/libs/mongodb/db&quot;</code></p><blockquote><p>Import 省略package名导入</p></blockquote><p>这里的点.符号表示,对包 lib 的调用直接省略包名,您我以后就是一家人,不分彼此,您的东西就像我就的一样,随便用.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import . &quot;github.com/libragen/felix/lib&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">SayHello() //如果没有.忽略包名,那么需要lib.SayHello()。不过这样可能要注意函数名或变量名是否会冲突，个人不推荐</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Import  执行初始化工作导入</p></blockquote><p><code>import _ &quot;github.com/libragen/felix/lib&quot;</code></p><p>形象解释:这里说的是我还不准备现在使用您们家的东西,但得提前告诉一声.您先做好准备,先准备好饭菜,等我来就行,也有可能我压根就不来.</p><p>具体解释:特殊符号“_” <strong>仅仅</strong>会导致 lib 执行初始化工作,如初始化全局变量,<strong>调用 init 函数</strong>。而正常导入一个包的时候，该包的init和其他函数都会被导入。</p><blockquote><p> package和文件的关系</p></blockquote><p><strong>一个文件夹下只能有一个package.</strong></p><p>import后面的其实是<code>GOPATH</code>开始的相对目录路径,包括最后一段.</p><ul><li>但由于一个目录下只能有一个<code>package</code>,所以<code>import</code>一个路径就等于是<code>import</code>了这个路径下的包.</li><li>注意,这里指的是“直接包含”的go文件. 如果有子目录,那么子目录的父目录是完全两个包.</li><li>比如您实现了一个计算器<code>package</code>,名叫calc,位于calc目录下; 但又想给别人一个使用范例,于是在<code>calc</code>下可以建个<code>example</code>子目录（<code>calc/example/</code>）, 这个子目录里有个<code>example.go（calc/example/example.go）</code>. 此时,<code>example.go</code>可以是main包,里面还可以有个main函数.<br>&amp;nbsp;<br>&amp;nbsp;</li></ul><p><strong>一个<code>package</code>的文件不能在多个文件夹下.</strong></p><ul><li>如果多个文件夹下有重名的<code>package</code>,它们其实是彼此无关的package.</li><li>如果一个<code>go</code>文件需要同时使用不同目录下的同名<code>package</code>,需要在<code>import</code>这些目录时为每个目录指定一个package的<strong>别名</strong>.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GO入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO 数据类型(入门篇必读)</title>
      <link href="/2021/08/16/GO-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/08/16/GO-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为什么是必读？因为这边会给出这个系列的参考&#x2F;出处文章地址</p></blockquote><p><a href="https://mojotv.cn/">https://mojotv.cn/</a></p><blockquote><p> 变量声明语法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a int //声明一个int类型的变量</span><br><span class="line"></span><br><span class="line">var b struct &#123; //声明一个结构体</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 8 //声明变量的同时赋值,编译器自动推导其数据类型</span><br><span class="line"></span><br><span class="line">var a int = 8 //声明变量的同时赋值</span><br><span class="line"></span><br><span class="line">//声明变量的同时赋值更习惯用&quot;:=&quot;，但注意全局变量不可以用&quot;:=&quot;</span><br><span class="line">a := 8</span><br></pre></td></tr></table></figure><p><strong>go可使用var关键字声明全局变量,但是:&#x3D;这种方式是不能用在全局变量中的.:&#x3D;只能用在函数体内部.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    a int</span><br><span class="line">    b bool</span><br><span class="line">    xx,yy,dd string=&quot;xx&quot;,&quot;yy&quot;,&quot;dd&quot;</span><br><span class="line">    //这里省略变量类型也是可以的.</span><br><span class="line">    zz,aa=&quot;zz&quot;,&quot;aa&quot;        //注意用&quot;=&quot;，不能用&quot;:=&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>go函数体内的变量是如果被声明了,那么必须使用,不然会报错。注:全局变量声明未使用不会报错</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//已声明,但如果不想使用可以加上_=varName,表示为已抛弃的变量.</span><br><span class="line">var a=1</span><br><span class="line">//标识为已抛弃的变量.</span><br><span class="line">_=a  </span><br></pre></td></tr></table></figure><blockquote><p>变量初始化</p></blockquote><p><strong>Go 语言在声明变量时会默认给变量赋个当前类型的<code>空值</code>&#x2F;<code>零值</code></strong></p><p>在方法中声明一个临时变量并赋初值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//推荐,会更新值的格式自动声明变量类型</span><br><span class="line">tmpStr :=&quot;&quot;</span><br></pre></td></tr></table></figure><p>当一个变量或者新值被创建时, 如果没有为其明确指定初始值,go语言会自动初始化其值为此类型对应的零值。</p><table><thead><tr><th align="center">类型</th><th align="center"><strong>零值</strong></th></tr></thead><tbody><tr><td align="center">数值类型</td><td align="center">0</td></tr><tr><td align="center">布尔类型</td><td align="center">false</td></tr><tr><td align="center">字符串</td><td align="center">“”（空字符串）</td></tr><tr><td align="center">slice</td><td align="center">nil</td></tr><tr><td align="center">map</td><td align="center">nil</td></tr><tr><td align="center">指针</td><td align="center">nil</td></tr><tr><td align="center">函数</td><td align="center">nil</td></tr><tr><td align="center">接口</td><td align="center">nil</td></tr><tr><td align="center">信道</td><td align="center">nil</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> GO入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客中插入音乐</title>
      <link href="/2021/08/03/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90/"/>
      <url>/2021/08/03/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h3 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h3><p>具体成功已体现在<code>网络掩码</code>文章底部。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>一款html5音乐播放器：Aplayer。把Aplayer加入hexo需要用到hexo-tag-aplayer插件。</p><p>切换到hexo目录，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure><p>安装完成后，在需要添加音乐的地方加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% aplayer &quot;歌曲名称&quot; &quot;作者&quot; &quot;音乐_url&quot; &quot;封面图片_url&quot; &quot;autoplay&quot; %&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/6e41e3191963">文章链接</a></p><h3 id="网易云外链的处理"><a href="#网易云外链的处理" class="headerlink" title="网易云外链的处理"></a>网易云外链的处理</h3><p>网易云提供的外链连接无法成功播放，所以找到一篇解决的文章。</p><p>例如：杨钰莹的心雨，网址是：<code>http://music.163.com/#/song?id=317151</code></p><p>很明显，ID是317151</p><p>那么，这首歌的真实地址就是：<code>http://music.163.com/song/media/outer/url?id=317151.mp3</code></p><p><a href="https://www.cnblogs.com/MirageFox/p/7995929.html">文章链接</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>mac端(<code>win端没有测试过</code>)控制不了音量大小，只能空过电脑或耳机条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% aplayer &quot;U&quot; &quot;许杨玉琢&quot; &quot;https://music.163.com/song/media/outer/url?id=1475649128.mp3&quot; &quot;/yyzka.jpeg&quot; %&#125;</span><br></pre></td></tr></table></figure><p>当<code>_config.yml asset_inject: false</code>时，上面是无效的，需要用下面。</p><div class="aplayer no-destroy" data-id="1846489859" data-server="netease" data-type="song" data-autoplay="false" data-lrctype="-1"> </div>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络掩码</title>
      <link href="/2021/08/03/%E7%BD%91%E7%BB%9C%E6%8E%A9%E7%A0%81/"/>
      <url>/2021/08/03/%E7%BD%91%E7%BB%9C%E6%8E%A9%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="ip地址的组成（网络位-主机位）"><a href="#ip地址的组成（网络位-主机位）" class="headerlink" title="ip地址的组成（网络位+主机位）"></a>ip地址的组成（网络位+主机位）</h3><p><strong>IP地址采用分层结构；</strong></p><p>IP地址是由网络号（net ID）与主机号（host ID）两部分组成的。</p><p><strong>根据不同的取值范围，IP地址可以分为五类</strong>；IP地址中的前5位用于标识IP地址的类别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A类地址的第一位为0；  127 =&gt; 0(128)1(64)1(32)1(16) 1(8)1(4)1(2)1(1)</span><br><span class="line">网络位7(8-1)位，主机号24位(32-7-1 = 24)</span><br><span class="line"></span><br><span class="line">B类地址的前两位为10； 191 =&gt; 1(128)0(64)1(32)1(16) 1(8)1(4)1(2)1(1)</span><br><span class="line">网络位14(8+8-2)位，主机号16位(32-14-2 = 16)</span><br><span class="line"></span><br><span class="line">C类地址的前三位为110；223 =&gt; 1(128)1(64)0(32)1(16) 1(8)1(4)1(2)1(1)</span><br><span class="line">网络位21(8+8+8-3)位，主机号位(32-21-3 = 8)</span><br><span class="line"></span><br><span class="line">D类地址的前四位为1110；</span><br><span class="line">E类地址的前五位为11110；</span><br></pre></td></tr></table></figure><p><img src="/2021/08/03/%E7%BD%91%E7%BB%9C%E6%8E%A9%E7%A0%81/wl_1.png" alt="png"></p><p>实际大多通过<code>子网掩码</code>来区分网络位和主机位，子网掩码跟IP地址一一对应，子网掩码为1的是网络位，为0的是主机位。<br>如：192.168.1.2 掩码255.255.255.0 。网络位192.168.1 主机位是2</p><p>举个例子：比如172.16.2.160&#x2F;255.255.255.0</p><p>这个IP地址的【网络号】就是172.16.2.0 主机号为   0.0.0.160 </p><blockquote><p>划分子网情况</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">如：172.16.2.160/255.255.255.192(IP地址/掩码)</span><br><span class="line"></span><br><span class="line">1010   1100   0001   0000   0000   0010   1010   0000   (二进制)</span><br><span class="line"></span><br><span class="line">1111   1111   1111   1111   1111   1111   1100   0000  （子网掩码）</span><br><span class="line"></span><br><span class="line">------------------------------------------相&quot;与&quot;(理解成相乘）</span><br><span class="line"></span><br><span class="line">1010   1100   0001   0000   0000   0010   1000   0000（172.16.2.128这就是子网号）</span><br><span class="line"></span><br><span class="line">1010   1100   0001   0000   0000   0010   1000   0001（172.16.2.129是第一个主机）</span><br><span class="line"></span><br><span class="line">1010   1100   0001   0000   0000   0010   1011   1110（172.16.2.190最后一个主机）</span><br><span class="line"></span><br><span class="line">1010   1100   0001   0000   0000   0010   1011   1111   广播地址  172.16.2.191 </span><br><span class="line"></span><br><span class="line">个人的理解:</span><br><span class="line">通过ip二进制和子网掩码二进制&quot;与&quot;可以发现，子网掩码二进制 1 的部分代表&quot;网络位&quot;, 0 的部分代表&quot;主机位&quot;，</span><br><span class="line">上面的例子可以看出&quot;主机位&quot;有6位，那么最后一段8位前两位是定的10，所以&quot;第一个主机位&quot;是1000 0001，&quot;最后一个主机位&quot;是1011 1110，因为还要留一个&quot;广播地址&quot;1011 1111。 </span><br></pre></td></tr></table></figure><blockquote><p>子网掩码的作用：</p></blockquote><ol><li>将一类ip地址（也就是只确定的网络号的ip）划分为更加小的子网络(<code>通常得到一个c类ip,如：212.26.220.0最后一组是主机号（最大255），用子网掩码分成更小的网段</code>）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">因为掩码的值是连续的1，那么子网掩码的值也就是有规律的：</span><br><span class="line">比如</span><br><span class="line">1000 0000 ---&gt; 128</span><br><span class="line">1100 0000 ---&gt; 192</span><br><span class="line">1110 0000 ---&gt; 224</span><br><span class="line">1111 0000 ---&gt; 240</span><br><span class="line">1111 1000 ---&gt; 248</span><br><span class="line">1111 1100 ---&gt; 252</span><br><span class="line">1111 1110 ---&gt; 254</span><br></pre></td></tr></table></figure><ol start="2"><li>将相邻的网络地址合并成同一逻辑网络</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">两个C类IP地址215.60.30.0与215.60.31.0与子网掩码255.255.254.0</span><br><span class="line">11010111.00111100.00011110.00000000--&gt;215.60.30.0</span><br><span class="line">11010111.00111100.00011111.00000000--&gt;215.60.31.0</span><br><span class="line">11111111.11111111.11111110.10000000--&gt;255.255.254.0//掩码</span><br><span class="line">11010111.00111100.00011110.00000000--&gt;215.60.30.0//都是该网段</span><br></pre></td></tr></table></figure><p>注意：一个错误的理解：子网掩码主要目的是增加了ip数量！！！其实并没有增加！！！（<code>也不能说没有增加，比如相同的ip不同子网掩码，实际公网是不存在相同的ip,如果说是两个局域网这种情况，不知道算不算增加了</code>）</p><p>补充：</p><ul><li><p>只知道ip地址那么只能知道是属于哪一类ip。或者认为没有子网络，比如c类ip，那么前3组是网络号，后面一组是主机号</p></li><li><p>只有知道子网掩码和ip，才能知道具体的网段和主机号</p></li><li><p>相同子网掩码未必是同一网段ip,同一网段的ip必然有相同的子网掩码。</p></li></ul><blockquote><p>“IP地址&#x2F; 数字” 是什么意思？例如 192.168.5.12 &#x2F; 21</p></blockquote><p>数字是子网掩码位（数），说明子网掩码由21个1组成，即 子网掩码是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111 11111111 11111000 00000000  ，也就是255.255.248.0</span><br></pre></td></tr></table></figure><p><a href="http://t.zoukankan.com/straybirds-p-5319604.html">文章链接</a></p><h3 id="子网掩码-网络掩码-的位数"><a href="#子网掩码-网络掩码-的位数" class="headerlink" title="子网掩码(网络掩码)的位数"></a>子网掩码(网络掩码)的位数</h3><p>255.255.255.0  &#x3D;&gt; &#x2F; 24</p><p>1111 1111 1111 1111 1111 1111 0000 0000  &#x3D; 24（总长32，1算，0不算）</p><h4 id="已知IP地址和子网掩码-如何快速计算是否在同一网段-仍待验证"><a href="#已知IP地址和子网掩码-如何快速计算是否在同一网段-仍待验证" class="headerlink" title="已知IP地址和子网掩码,如何快速计算是否在同一网段(仍待验证)"></a>已知IP地址和子网掩码,如何快速计算是否在同一网段(仍待验证)</h4><p>下面哪些IP位于同一子网中？</p><ul><li>192.168.78.36&#x2F;29</li><li>192.168.78.42&#x2F;29</li><li>192.168.78.41&#x2F;29</li><li>192.168.78.45&#x2F;29</li><li>192.168.78.48&#x2F;29</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">通过上面子网掩码29位，我们可以知道 网络位是29位，主机位3位。所以，判断是否同一网段，看&quot;网络位&quot;是否相同。</span><br><span class="line">因为前面都是相同的，所以看最后一段的数字二进制8位扣除3位&quot;主机位&quot;后是否相同。</span><br><span class="line"></span><br><span class="line">36 (2 +4)                      0010 0100   =&gt;  0010 0 (扣除3位主机位)</span><br><span class="line"></span><br><span class="line">42  (32 + 8 + 2)             0010 1010    =&gt; 0010 1</span><br><span class="line"></span><br><span class="line">41  (32 + 8 + 1)              0010 1001    =&gt; 0010 1</span><br><span class="line"></span><br><span class="line">45  (32 + 8 + 4 +1)         0010 1101    =&gt;  0010 1</span><br><span class="line"></span><br><span class="line">48  (32 + 16)                  0011  0000   =&gt; 0011  0</span><br><span class="line"></span><br><span class="line">可以看出 42 41 45在同一网段</span><br><span class="line"></span><br><span class="line">那么快速的方法</span><br><span class="line">主机位3位： 2^3 = 8</span><br><span class="line">36/8 = 4</span><br><span class="line">42/8 = 5</span><br><span class="line">41/8 = 5</span><br><span class="line">45/8 = 5</span><br><span class="line">48/8 = 6</span><br></pre></td></tr></table></figure><p>下面哪些IP位于同一子网中？</p><ul><li>192.168.165.24&#x2F;255.255.254.0 和 192.168.164.78&#x2F;255.255.254.0</li><li>192.168.165.24&#x2F;255.255.255.255 和 192.168.164.78&#x2F;255.255.255.255</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">第一组计算:</span><br><span class="line">255.255.254.0        2^9  =  256</span><br><span class="line"></span><br><span class="line">16524 / 256 = 64.5</span><br><span class="line"></span><br><span class="line">16478 / 256  = 64.3</span><br><span class="line"></span><br><span class="line">商64，相同</span><br><span class="line"></span><br><span class="line">第二组计算:</span><br><span class="line">255.255.255.255  2^8 = 128</span><br><span class="line"></span><br><span class="line">16524/128 = 129</span><br><span class="line"></span><br><span class="line">16478/128 = 128.7</span><br><span class="line"></span><br><span class="line">商129和128，不相同</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/VmXgt6usAfPKyfmsAM_UZg">文章地址-还有其他知识点哦</a></p><h3 id="IP地址、子网掩码、网段、网关的关系"><a href="#IP地址、子网掩码、网段、网关的关系" class="headerlink" title="IP地址、子网掩码、网段、网关的关系"></a>IP地址、子网掩码、网段、网关的关系</h3><p>IP地址、子网掩码、网络地址、广播地址、网段、网关的关系,例：</p><table><thead><tr><th>name</th><th>终端A</th><th>终端B</th><th>终端C</th></tr></thead><tbody><tr><td>IP地址</td><td>192.168.1.10</td><td>192.168.1.23</td><td>192.168.1.40</td></tr><tr><td>子网掩码</td><td>255.255.255.224</td><td>255.255.255.224</td><td>255.255.255.224</td></tr><tr><td>网络地址</td><td>192.168.1.0</td><td>192.168.1.0</td><td>192.168.1.32</td></tr><tr><td>广播地址</td><td>192.168.1.31</td><td>192.168.1.31</td><td>192.168.1.63</td></tr><tr><td>网段</td><td>192.168.1.0~192.168.1.31</td><td>192.168.1.0~192.168.1.31</td><td>192.168.1.31~192.168.1.63</td></tr><tr><td>网关</td><td>192.168.1.1</td><td>192.168.1.1</td><td>192.168.1.32</td></tr></tbody></table><blockquote><p>总结：</p></blockquote><ul><li>网络地址&#x3D;IP地址&amp;子网掩码</li><li>广播地址&#x3D;IP地址|（！子网掩码）</li><li>网段：网络地址相同的IP地址属于同一网段，即同一子网。</li><li>网关：同一网段（子网）间终端可直接通信，如终端A和终端B；不在同一网段（子网）的终端不能直接通信，需要通过网关才能通信，如终端A和终端C。</li></ul><p><a href="https://blog.csdn.net/qq_41324483/article/details/100179816">文章地址</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% aplayer &quot;Giri Giri&quot; &quot;许杨玉琢&quot; &quot;https://music.163.com/song/media/outer/url?id=1865305744.mp3&quot; &quot;/yyzka.jpeg&quot; &quot;autoplay&quot; %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希算法</title>
      <link href="/2021/07/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2021/07/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>为什么开启这一篇呢？因为后面要对gopush进行讲解。</p><h3 id="一致性哈希算法-图片网上资源，联系可删，描述均为自己观点"><a href="#一致性哈希算法-图片网上资源，联系可删，描述均为自己观点" class="headerlink" title="一致性哈希算法(图片网上资源，联系可删，描述均为自己观点)"></a>一致性哈希算法(图片网上资源，联系可删，描述均为自己观点)</h3><blockquote><p>0~2^32-1 可以理解为一个圆的外环均匀分布为2^32个点 &#x3D;&gt; key</p></blockquote><p><img src="/2021/07/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hx1.jpg" alt="jpg"></p><blockquote><p>在圆上分布均匀分布4个节点(node)</p></blockquote><p><img src="/2021/07/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hx2.jpg" alt="jpg"></p><blockquote><p>查找方式</p></blockquote><p><img src="/2021/07/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hx3.jpg" alt="jpg"></p><blockquote><p>删除节点影响</p></blockquote><p><img src="/2021/07/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hx4.jpg" alt="jpg"></p><blockquote><p>添加节点影响</p></blockquote><p><img src="/2021/07/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hx5.jpg" alt="jpg"></p><blockquote><p>节点少的影响</p></blockquote><p><img src="/2021/07/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hx6.jpg" alt="jpg"></p><blockquote><p>虚拟节点</p></blockquote><p><img src="/2021/07/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hx7.jpg" alt="jpg"></p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>定义:记录的存储位置 &#x3D; f(关键字)</p><p>第一代：SHA-1(1993),MD5(1992),CRC(1975),Lookup3(2006)<br>第二代：MurmurHash(2008)<br>第三代：CityHash,SpookyHash(2011)</p><h3 id="通过key获取comet-node节点"><a href="#通过key获取comet-node节点" class="headerlink" title="通过key获取comet-node节点"></a>通过key获取comet-node节点</h3><p>MurmurHash 是一种非加密型哈希函数，适用于一般的哈希检索操作。与其它流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分布特征表现更良好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// init consistent hashing circle</span><br><span class="line">func (k *Ketama) initCircle2(node []string) &#123;</span><br><span class="line">h := NewMurmur3C()</span><br><span class="line">for _, str := range node &#123;</span><br><span class="line">for i := 0; i &lt; k.vnode; i++ &#123;</span><br><span class="line">vnode := fmt.Sprintf(&quot;%s#%d&quot;, str, i)</span><br><span class="line">h.Write([]byte(vnode))</span><br><span class="line">vpos := uint(h.Sum32())</span><br><span class="line">k.nodes = append(k.nodes, vpos)</span><br><span class="line">k.nodesMapping[vpos] = str</span><br><span class="line">h.Reset()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Sort(UIntSlice(k.nodes))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> gopush </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用markdown图片无法显示问题(引用,亲测可用)</title>
      <link href="/2021/07/13/hexo%E4%BD%BF%E7%94%A8markdown%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2021/07/13/hexo%E4%BD%BF%E7%94%A8markdown%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>hexo默认无法自动处理文章插入本地图片，需要通过扩展插件支持。</p><blockquote><p>如何处理图片路径问题</p></blockquote><ul><li><p>配置_config.yml里面的post_asset_folder:false这个选项设置为true。</p></li><li><p>安装hexo-asset-image，运行hexo n “xxxx”来生成md博文时，&#x2F;source&#x2F;_posts文件夹内除了xxxx.md文件还有一个同名的文件夹，把图片放入该文件夹。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save </span><br></pre></td></tr></table></figure><ul><li>使用<code>![图片类型或空](存放图片文件夹名/图片名.png)</code>直接插入图片即可。</li></ul><blockquote><p>关于插件问题</p></blockquote><p>由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理data.permalink链接时出现路径错误，把年月去掉了，导致最后生成的路径为%d&#x2F;xxx&#x2F;xxx需要对其做兼容处理。通过判断当前版本是否等于3的版本做不同的路径分割。</p><ul><li><p>在代码中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var version = String(hexo.version).split(&#x27;.&#x27;);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;</p></li><li><p>修改<code>date.permalink</code>处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var link = data.permalink;  </span><br><span class="line">if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) </span><br><span class="line">    var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1; </span><br><span class="line">else </span><br><span class="line">    var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1;</span><br></pre></td></tr></table></figure><p>重新生成静态文件即可正确显示。</p></li><li><p>可直接安装已经修改过得插件<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code>。</p></li></ul><p><strong>如果不行，考虑用这个</strong>安装插件</p><p><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p><hr><p>作者：菜鸡_快递到了<br>链接：<a href="https://www.jianshu.com/p/3db6a61d3782">https://www.jianshu.com/p/3db6a61d3782</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口超时优化代码案例记录</title>
      <link href="/2021/07/13/%E6%8E%A5%E5%8F%A3%E8%B6%85%E6%97%B6%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/07/13/%E6%8E%A5%E5%8F%A3%E8%B6%85%E6%97%B6%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>语言:PHP</strong></p><p><strong>接口超时问题</strong>是一个比较常见的场景，当接口中包含有较多的<strong>数据库查询语句</strong>,并且涉及到<strong>循环执行</strong>这些查询语句时，执行时间就会变大很多，初期可能因为新表数据量少还在接受范围，当后期数据量变大后，可能就会消耗极的时间，甚至是超时。</p><h3 id="方法一-延长可执行时间"><a href="#方法一-延长可执行时间" class="headerlink" title="方法一:延长可执行时间"></a>方法一:延长可执行时间</h3><p>对面这个问题，我们可以延长可执行时间，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">set_time_limit</span>(<span class="number">30</span>); <span class="comment">//设置程序执行时间为30s</span></span><br></pre></td></tr></table></figure><p>但这种方式,对用户其实特别不友好。除了一些特殊场景外，并不建议无限制的延长可执行时间。特别是<strong>不要</strong>将时间设置为<code>set_time_limit(0)</code>无限时长，这样一旦遇到死循环情况，执行就不会结束，可能会导致大量进程堆积，极大的消耗CPU。</p><h3 id="方法二-消息队列"><a href="#方法二-消息队列" class="headerlink" title="方法二:消息队列"></a>方法二:消息队列</h3><p>通过<strong>消息队列</strong>的方式，将请求<strong>插入队列</strong>(可以借助Redis等缓存)，直接返回结果。再脚本通过获取<strong>队列信息</strong>执行需要的操作。</p><ul><li>优点：这样返回的速度会极快，而且内容也可以有效执行。</li><li>缺点：脚本如果执行失败，但之前请求已经返回成功。</li><li>优化： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 脚本完成时通过请求**回调接口**告知执行结果;(当然,脚本执行过程中的日志记录也很重要)</span><br><span class="line">2. 前端收到接口返回成功信息时，展示给用户的内容&quot;友好&quot;调整，例如执行完成、已执行。前端提供查看结果页，及时更新状态;</span><br><span class="line">3. 如果明确执行的时间是较长的，前端可以适当做一些等待动画，让整个完成等待时间有一定延长，对后续用户查看结果是友好的.</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法三-php-接口提前响应返回，然后继续执行后台逻辑"><a href="#方法三-php-接口提前响应返回，然后继续执行后台逻辑" class="headerlink" title="方法三:php 接口提前响应返回，然后继续执行后台逻辑"></a>方法三:php 接口提前响应返回，然后继续执行后台逻辑</h3><p>php 程序(以 php5.6 版本进行演示) 是可以在接口中，进行一些异步操作的， 不过写法有点特殊。</p><h4 id="1-ob-end-clean"><a href="#1-ob-end-clean" class="headerlink" title="1. ob_end_clean()"></a>1. ob_end_clean()</h4><p>这个是清除之前的缓冲内容，这是必需的，如果之前的缓存不为空的话，里面可能有 http 头或者其它内容，导致后面的内容不能及时的输出</p><h4 id="2-header-“Connection-close”"><a href="#2-header-“Connection-close”" class="headerlink" title="2. header(“Connection: close”)"></a>2. header(“Connection: close”)</h4><p>告诉浏览器，连接关闭了，这样浏览器就不用等待服务器的响应。</p><h4 id="3-header-“HTTP-x2F-1-1-200-OK”"><a href="#3-header-“HTTP-x2F-1-1-200-OK”" class="headerlink" title="3. header(“HTTP&#x2F;1.1 200 OK”)"></a>3. header(“HTTP&#x2F;1.1 200 OK”)</h4><p>发送 200 状态码，要不然可能浏览器会重试，特别是有代理的情况下</p><h4 id="4-ob-start"><a href="#4-ob-start" class="headerlink" title="4. ob_start()"></a>4. ob_start()</h4><p>开启当前代码缓冲</p><h4 id="5-ob-end-flush"><a href="#5-ob-end-flush" class="headerlink" title="5. ob_end_flush()"></a>5. ob_end_flush()</h4><p>输出当前缓冲</p><h4 id="6-flush"><a href="#6-flush" class="headerlink" title="6. flush()"></a>6. flush()</h4><p>输出PHP缓冲</p><h4 id="7-ignore-user-abort-true"><a href="#7-ignore-user-abort-true" class="headerlink" title="7. ignore_user_abort(true)"></a>7. ignore_user_abort(true)</h4><p>在关闭连接后，继续运行php脚本</p><h4 id="8-set-time-limit-0"><a href="#8-set-time-limit-0" class="headerlink" title="8. set_time_limit(0)"></a>8. set_time_limit(0)</h4><p>no time limit，不设置超时时间（根据实际情况使用）</p><h4 id="9-fastcgi-finish-request"><a href="#9-fastcgi-finish-request" class="headerlink" title="9. fastcgi_finish_request()"></a>9. fastcgi_finish_request()</h4><p>这个在有用 fpm 的时候，会用到， 也是将提前返回响应，然后接下来的逻辑后台执行。</p><p>封装函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 异步的成功返回函数</span><br><span class="line">public function returnSuccessJsonDataAsync($otherReturnData = [], $timeout = 60, $allowCors = true)&#123;</span><br><span class="line">    $msgData = [&#x27;code&#x27; =&gt; 1, &#x27;msg&#x27; =&gt; &#x27;Success&#x27;];</span><br><span class="line">    if(empty($otherReturnData))&#123;</span><br><span class="line">        $data = $msgData;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $data = array_merge($msgData, $otherReturnData);</span><br><span class="line">    &#125;</span><br><span class="line">    // 接下来提前告诉 浏览器返回， 其他的后台允许</span><br><span class="line">    ob_end_clean();</span><br><span class="line">    //告诉浏览器，连接关闭了，这样浏览器就不用等待服务器的响应</span><br><span class="line">    header(&quot;Connection: close&quot;);</span><br><span class="line">    header(&quot;HTTP/1.1 200 OK&quot;);</span><br><span class="line">    ob_start();</span><br><span class="line">    $str = json_encode($data);</span><br><span class="line">    header(&#x27;Content-type: application/json&#x27;);</span><br><span class="line">    header(&#x27;Content-Length: &#x27; . strlen($str));</span><br><span class="line">    </span><br><span class="line">    // 如果允许跨域，那么就设置跨域头</span><br><span class="line">    if($allowCors)&#123;</span><br><span class="line">        $origin = Yii::$app-&gt;request-&gt;getHeaders()-&gt;get(&#x27;Origin&#x27;);</span><br><span class="line">        header(&quot;Access-Control-Allow-Origin: &#123;$origin&#125;&quot;);</span><br><span class="line">        header(&#x27;Access-Control-Allow-Credentials: true&#x27;);</span><br><span class="line">        header(&#x27;Access-Control-Allow-Methods: POST, GET, OPTIONS&#x27;);</span><br><span class="line">        header(&#x27;Access-Control-Allow-Headers: origin, content-type&#x27;);</span><br><span class="line">        header(&#x27;Access-Control-Max-Age: 86400&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    echo $str;</span><br><span class="line"></span><br><span class="line">    ob_end_flush();</span><br><span class="line">    if(ob_get_length())&#123;</span><br><span class="line">        ob_flush();</span><br><span class="line">    &#125;</span><br><span class="line">    flush();</span><br><span class="line">    // yii或yaf默认不会立即输出，加上此句即可（前提是用的fpm）</span><br><span class="line">    if (function_exists(&quot;fastcgi_finish_request&quot;)) &#123;</span><br><span class="line">        fastcgi_finish_request(); // 响应完成, 立即返回到前端,关闭连接</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /******** background process starts here ********/</span><br><span class="line">    //在关闭连接后，继续运行php脚本</span><br><span class="line">    ignore_user_abort(true);</span><br><span class="line">    //no time limit，不设置超时时间（根据实际情况使用）</span><br><span class="line">    set_time_limit($timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/superhosts/article/details/42292053">深入理解ob_flush和flush的区别(ob_flush()与flush()使用方法)</a></p><p><a href="https://www.php.cn/php-weizijiaocheng-370354.html">php：flush()和ob_flush(),ob_end_flush()用法区别详解</a></p><h3 id="方法四-异步并行-引入swoole或用go"><a href="#方法四-异步并行-引入swoole或用go" class="headerlink" title="方法四:异步并行,引入swoole或用go"></a>方法四:异步并行,引入swoole或用go</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 优化案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-解决go的fatal error: concurrent map writes map非并发安全</title>
      <link href="/2021/07/06/Go-%E8%A7%A3%E5%86%B3go%E7%9A%84fatal-error-concurrent-map-writes-map%E9%9D%9E%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/"/>
      <url>/2021/07/06/Go-%E8%A7%A3%E5%86%B3go%E7%9A%84fatal-error-concurrent-map-writes-map%E9%9D%9E%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>普及概念：</p></blockquote><h4 id="普及1"><a href="#普及1" class="headerlink" title="普及1"></a>普及1</h4><p><a href="https://studygolang.com/articles/12972?fr=sidebar">Golang sync.WaitGroup的用法</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    for i := 0; i &lt; 100 ; i++&#123;</span><br><span class="line">        go fmt.Println(i) //并行</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述方法，其实就是通过sleep等待go并行线程都完成再往下走，但是这个也是有问题的因为sleep的时间无法精确。</p><ul><li>可以考虑使用管道来完成上述操作：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    c := make(chan bool, 100)</span><br><span class="line">    for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">        go func(i int) &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            c &lt;- true</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">        &lt;-c</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先可以肯定的是使用管道是能达到我们的目的的，而且不但能达到目的，还能十分完美的达到目的。</p><ul><li>但go语言中有一个其他的工具<code>sync.WaitGroup</code> 能更加方便的帮助我们达到这个目的。</li></ul><p><code>WaitGroup</code> 对象内部有一个计数器，最初从0开始，它有三个方法：<code>Add(), Done(), Wait()</code> 用来控制计数器的数量。<code>Add(n)</code> 把计数器设置为<code>n</code> ，<code>Done()</code> 每次把计数器<code>-1</code> ，<code>wait()</code> 会阻塞代码的运行，直到计数器地值减为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(100) //计算器设置为100</span><br><span class="line">    for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">        go func(i int) &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            wg.Done() //减1</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() //等待100减到0，取消阻塞，往下执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意：</p><p>1.我们不能使用<code>Add()</code> 给<code>wg</code> 设置一个负值</p><p>2.WaitGroup对象不是一个引用类型</p><p>WaitGroup对象不是一个引用类型，在通过函数传值的时候需要使用地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(100)</span><br><span class="line">    for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">        go f(i, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一定要通过指针传值，不然进程会进入死锁状态</span><br><span class="line">func f(i int, wg *sync.WaitGroup) &#123; </span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="普及2"><a href="#普及2" class="headerlink" title="普及2"></a>普及2</h4><p><a href="http://c.biancheng.net/view/61.html">Go语言defer (延迟执行语句)</a></p><p>Go语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的<strong>逆序</strong>进行执行，也就是说，<strong>先</strong>被 defer 的语句<strong>最后</strong>被执行，<strong>最后</strong>被 defer 的语句，<strong>最先</strong>被执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">好处及用处就不用说了。</span><br><span class="line">这边讲关于sync.WaitGroup的实际应用。</span><br><span class="line">defer wg.Done()  //可以将这条语句放在函数中，不用担心句末遗忘，或者后续添加内容遗忘移动位置</span><br></pre></td></tr></table></figure><h4 id="普及3"><a href="#普及3" class="headerlink" title="普及3"></a>普及3</h4><p><a href="https://www.cnblogs.com/setevn/p/8977922.html">golang中sync.RWMutex和sync.Mutex区别</a></p><p>golang中sync包实现了两种锁<strong>Mutex （互斥锁）</strong>和<strong>RWMutex（读写锁）</strong>，其中RWMutex是基于Mutex实现的，只读锁的实现使用类似引用计数器的功能．</p><p>其中<strong>Mutex</strong>为互斥锁，Lock()加锁，Unlock()解锁，使用Lock()加锁后，便不能再次对其进行加锁，直到利用Unlock()解锁对其解锁后，才能再次加锁．适用于<strong>读写不确定</strong>场景，即读写次数没有明显的区别，并且只允许只有一个读或者写的场景，所以该锁叶叫做<strong>全局锁</strong>。</p><p><strong>RWMutex</strong>是一个读写锁，该锁可以加多个读锁或者一个写锁，其经常用于读次数远远多于写次数的场景．</p><p><strong><a href="https://blog.csdn.net/u010230794/article/details/78554370">RWMutex的使用主要事项</a></strong></p><ul><li><strong>1、读锁的时候无需等待读锁的结束</strong></li><li><strong>2、读锁的时候要等待写锁的结束</strong></li><li><strong>3、写锁的时候要等待读锁的结束</strong></li><li><strong>4、写锁的时候要等待写锁的结束</strong></li></ul><blockquote><p>正题</p></blockquote><h4 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var wg sync.WaitGroup</span><br><span class="line">sortUrl := make(map[int]string) //map</span><br><span class="line">for index, url := range matchStr &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func(url string, i int) &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">screenChangeUrl, err := ChangeImageToOurService(url, accountId, &quot;Claw-GooglePlay-AppInfo-Screenshot-&quot;, i, AMS_STORE_PREFIX)</span><br><span class="line">if err == nil &#123;</span><br><span class="line">sortUrl[i] = screenChangeUrl //问题</span><br><span class="line">&#125;</span><br><span class="line">&#125;(url, index)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h4 id="为什么会报”fatal-error-concurrent-map-writes-map”？"><a href="#为什么会报”fatal-error-concurrent-map-writes-map”？" class="headerlink" title="为什么会报”fatal error: concurrent map writes map”？"></a>为什么会报”fatal error: concurrent map writes map”？</h4><p>因为map不是并发安全的 , 当有多个并发的groutine读写同一个map时，会出现panic错误。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在继续使用Map类型的情况下，常规解决方案一般分为两种。</p><ul><li>并发的groutine定义多个map，进行读写。这样就不存在同时读写一个map。这种的试用场景就是，</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a := make(map[int]string)</span><br><span class="line">b := make(map[int]string)</span><br><span class="line">go func()&#123;</span><br><span class="line">   a[1] = 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go func()&#123;</span><br><span class="line">    b[1] =5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>但更多是通过锁(适合上面代码)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var wg sync.WaitGroup</span><br><span class="line">locker := new(sync.Mutex) //互斥锁，这边也可以根据场景考虑用写锁</span><br><span class="line">sortUrl := make(map[int]string)</span><br><span class="line">for index, url := range matchStr &#123;</span><br><span class="line">    wg.Add(1)</span><br><span class="line">    go func(url string, i int) &#123;</span><br><span class="line">        locker.Lock() //锁定</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        defer locker.Unlock() //解锁</span><br><span class="line">        screenChangeUrl, err := ChangeImageToOurService(url, accountId, &quot;Claw-GooglePlay-AppInfo-Screenshot-&quot;, i, AMS_STORE_PREFIX)</span><br><span class="line">        if err == nil &#123;</span><br><span class="line">            sortUrl[i] = screenChangeUrl</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(url, index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以有效解决报错问题。但是会无形造成串行，因为都在等待解锁。</p><h4 id="使用并行的解决方案"><a href="#使用并行的解决方案" class="headerlink" title="使用并行的解决方案"></a>使用并行的解决方案</h4><ul><li>所以，我们想了两种方案，一种弃用map类型(这个该文章不描述)，另一种使用sync.Map(版本支持)。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">因为map本就是不适合并行的，所以go官方推出了sync.Map。</span><br><span class="line">通过测试，</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">var t2 = time.Now()</span><br><span class="line">var sortUrl sync.Map //新增</span><br><span class="line">start := time.Now()</span><br><span class="line">for index, url := range matchStr &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func(url string, i int) &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">urlString := &quot;url&quot; + &quot;,&quot; + fmt.Sprintf(&quot;%d&quot;,i)</span><br><span class="line">if i == 2 &#123;</span><br><span class="line">time.Sleep(3 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">if i == 3 &#123;</span><br><span class="line">time.Sleep(8 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">sortUrl.Store(i, urlString) //新增</span><br><span class="line">&#125;(url, index)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">elapsed := time.Since(start)</span><br><span class="line">log.Debug(elapsed)</span><br></pre></td></tr></table></figure><p>结果:elapsed为8.005294657s，证明可以并行。</p><ul><li>但是sync.Map和Map的使用却是有很大区别，下面介绍sync.Map的使用。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var sortUrl sync.Map //定义</span><br><span class="line">sortUrl.Store(i, urlString) //使用i为key,urlString为value</span><br><span class="line"></span><br><span class="line">// 遍历所有sync.Map中的键值对</span><br><span class="line">sortUrl.Range(func(k, v interface&#123;&#125;) bool &#123;</span><br><span class="line">  key := k.(int) //注意转换成int类型</span><br><span class="line">  keys = append(keys, key)</span><br><span class="line">  return true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">for k := range keys &#123;</span><br><span class="line">  key,_ := sortUrl.Load(k) //获取值，返回value interface&#123;&#125;, ok bool</span><br><span class="line">  keyValue := key.(string) //转成string类型</span><br><span class="line">  uploadSuccessUrl = append(uploadSuccessUrl, keyValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>更多操作可参考文档:<a href="http://c.biancheng.net/view/34.html">Go语言sync.Map (在并发环境中使用的map)</a></p><h4 id="附录介绍一些需要的类型转换文档"><a href="#附录介绍一些需要的类型转换文档" class="headerlink" title="附录介绍一些需要的类型转换文档:"></a>附录介绍一些需要的类型转换文档:</h4><p><a href="https://www.jb51.net/article/142447.htm">Golang 中整数转字符串的方法</a><br><a href="https://blog.csdn.net/xujiamin0022016/article/details/109226605">golang-interface转string</a><br><a href="https://studygolang.com/articles/7323">golang学习之interface与其它类型转换</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-单元测试篇(简单)</title>
      <link href="/2021/07/06/Go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%AF%87/"/>
      <url>/2021/07/06/Go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文章</p></blockquote><p><a href="https://studygolang.com/articles/2491">golang test测试使用</a></p><p><a href="https://geektutu.com/post/quick-go-test.html">Go Test 单元测试简明教程</a></p><p><a href="https://learnku.com/articles/33446">Golang 单元测试执行 _test.go 中的某个 func 方法</a></p><blockquote><p>正文</p></blockquote><p>为什么需要单元测试，因为你可能修改的只是一个方法，但如果整个接口都放进去测试，明显效率不高。</p><ul><li>创建测试go文件，测试文件以 _test.go 结尾;引入包 import “testing”;测试用的参数有且只有一个，在这里是 t *testing.T。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">if ans := Add(1, 2); ans != 3 &#123;</span><br><span class="line">t.Errorf(&quot;1 + 2 expected be 3, but %d got&quot;, ans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ans := Add(-10, -20); ans != -30 &#123;</span><br><span class="line">t.Errorf(&quot;-10 + -20 expected be -30, but %d got&quot;, ans)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基准测试(benchmark)的参数是 *testing.B，TestMain 的参数是 *testing.M 类型。</p><ul><li>运行 go test，该 package 下所有的测试用例都会被执行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">ok      example 0.009s</span><br></pre></td></tr></table></figure><ul><li>go test -v，-v 参数会显示每个用例的测试结果，另外 -cover 参数可以查看覆盖率。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">=== RUN   TestMul</span><br><span class="line">--- PASS: TestMul (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      example 0.007s</span><br></pre></td></tr></table></figure><ul><li>但我们更常用的是运行其中一个，例如要运行上面的TestAdd方法，用<code>-run</code>参数指定，该参数支持通配符 *，和部分正则表达式，例如 ^、$。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go test -run TestAdd -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      example 0.007s</span><br></pre></td></tr></table></figure>当然，go单元测试还有其他的使用内容，不过这边仅给最简单的。具体可以看上面的链接文档。</li></ul><blockquote><p>真实场景注意点</p></blockquote><ul><li>报错：flag provided but not defined: -test.timeout</li></ul><p>处理方法：注释掉flag.Parse()</p><p>理由：从flag.Parse()源码发现，他把go test的test当作一个参数处理，而flag没有对这个参数做处理导致解析失败。<a href="https://my.oschina.net/u/3223370/blog/4272500">链接</a></p><ul><li>最好在测试文件添加初始化，完成数据库之类的默认配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func init()  &#123;</span><br><span class="line">initConfig()</span><br><span class="line">initRedis()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL查询~ 存在一个表而不在另一个表中的数据</title>
      <link href="/2021/05/18/MYSQL%E6%9F%A5%E8%AF%A2-%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%80%8C%E4%B8%8D%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/05/18/MYSQL%E6%9F%A5%E8%AF%A2-%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%80%8C%E4%B8%8D%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>业务场景：</p></blockquote><p>account表保存的用户信息 包含 真正用户 和 测试用户(内部测试账号),test表保存测试用户信息，对应account表id字段test.account_id。</p><p>查询时需要剔除account表测试用户，找出account表id字段中，不与test表account字段相等的值。</p><blockquote><p>方法一: 使用 not in ,容易理解,效率低  执行时间为：8.6ms(其他数据相同方法)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注：这边因为account_id字段具有唯一性，所以才不用distinct去重。</span><br><span class="line"></span><br><span class="line">select account.id from account where account.id not in (select account_id from test)</span><br></pre></td></tr></table></figure><blockquote><p>方法二：使用 left join…on… , “test.account_id is null” 表示左连接之后在test.account_id 字段为 null的记录  执行时间：9ms(其他数据相同方法)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select account.id from account left join test on account.id = test.account_id where test.account_id is null</span><br></pre></td></tr></table></figure><blockquote><p>方法三: 逻辑相对复杂,但是速度最快  执行时间: 10.2ms(其他数据相同方法)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from account where (select count(1) as num from test where account.id = test.account_id) = 0</span><br><span class="line"></span><br><span class="line">当account表获取的id数据作为test表查询条件(account.id = test.account_id)时，数据为0的account表数据。</span><br></pre></td></tr></table></figure><p><strong>注：时间仅作为参考，还是要用实际数据模拟，语句可以用explain优化</strong></p><blockquote><p>参考链接</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/softidea/p/9482120.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO time篇</title>
      <link href="/2021/04/26/GO-time%E7%AF%87/"/>
      <url>/2021/04/26/GO-time%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="go-Time篇"><a href="#go-Time篇" class="headerlink" title="go Time篇"></a>go Time篇</h3><p>当前日期 time.Now().Format(“2006-01-02”)</p><p>当前时间 time.Now().Format(“2006-01-02 15:04:05”)</p><p>年月日 year, mon, day :&#x3D; time.Now().UTC().Date()      mon格式为month需要转换</p><p>也可以单独获取</p><p>加一天 time.Parse(“2006-01-02 15:04:05”, date).AddDate(0, 0, 1).Format(“2006-01-02 15:04:05”)</p><p>减一天 time.Parse(“2006-01-02 15:04:05”, date).AddDate(0, 0, -1).Format(“2006-01-02 15:04:05”)</p><p>0 0 1 前面两个零分别代表年，月    date初始日期</p><p><a href="https://blog.csdn.net/wschq/article/details/80114036">golang包time用法详解</a></p><p><a href="https://blog.csdn.net/qq_41004440/article/details/89252653">golang map 获取某个值</a></p><p><a href="https://blog.csdn.net/weixin_39524842/article/details/111890157">https://blog.csdn.net/weixin_39524842/article/details/111890157</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO mod篇</title>
      <link href="/2021/03/30/GO-mod%E7%AF%87/"/>
      <url>/2021/03/30/GO-mod%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="三分钟掌握Go-mod常用与高级操作"><a href="#三分钟掌握Go-mod常用与高级操作" class="headerlink" title="三分钟掌握Go mod常用与高级操作"></a>三分钟掌握Go mod常用与高级操作</h2><p><a href="https://zhuanlan.zhihu.com/p/103534192">链接</a></p><h2 id="go-mod-使用"><a href="#go-mod-使用" class="headerlink" title="go mod 使用"></a>go mod 使用</h2><p><a href="https://www.cnblogs.com/dhcn/p/11321376.html">链接</a></p><blockquote><p>更多内容 </p></blockquote><p><a href="./GO%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.md">跳转到</a></p><blockquote><p>pprof记录</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://pkg.go.dev/github.com/revel/modules/pprof#section-readme</span><br><span class="line"></span><br><span class="line">https://pkg.go.dev/net/http/pprof</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go指针篇</title>
      <link href="/2021/03/24/Go%E6%8C%87%E9%92%88%E7%AF%87/"/>
      <url>/2021/03/24/Go%E6%8C%87%E9%92%88%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>与 <a href="http://c.biancheng.net/java/">Java</a> 和 .NET 等编程语言不同，Go语言为程序员提供了控制<a href="http://c.biancheng.net/data_structure/">数据结构</a>指针的能力，但是，并不能进行指针运算。Go语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这对于构建运行良好的系统是非常重要的。指针对于性能的影响不言而喻，如果你想要做系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。</p><blockquote><p>概念</p></blockquote><p>指针（pointer）在Go语言中可以被拆分为两个核心概念：</p><ul><li><p>类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针<strong>不能</strong>进行偏移和运算。</p></li><li><p>切片，由指向起始元素的原始指针、元素数量和容量组成。</p></li></ul><p>受益于这样的约束和拆分，Go语言的指针类型变量即拥有指针高效访问的特点，又不会发生指针偏移，从而避免了非法修改关键性数据的问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p><p>切片比原始指针具备更强大的特性，而且更为安全。切片在发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。</p><p><strong>要明白指针，需要知道几个概念：指针地址、指针类型和指针取值</strong></p><blockquote><p>认识指针地址和指针类型</p></blockquote><p>一个指针变量可以指向任何一个值的<strong>内存地址</strong>，它所指向的值的<strong>内存地址</strong>在 32 和 64 位机器上分别占用 4 或 8 个字节，<strong>占用字节</strong>的大小与所指向的<strong>值</strong>的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。</p><p>每个变量在运行时都拥有一个地址，<strong>这个地址代表变量在内存中的位置</strong>。Go语言中使用在变量名前面添加<code>&amp;</code>操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v //v的类型为T</span><br></pre></td></tr></table></figure><p>其中 v 代表被取地址的变量，变量 v 的地址使用变量 ptr 进行接收。假设v的类型为<code>T</code>，ptr 的类型为<code>*T</code>，称做 T 的指针类型，<code>*</code>代表指针。</p><p>指针实际用法，可以通过下面的例子了解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (    </span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;    </span><br><span class="line">var cat int = 1    </span><br><span class="line">var str string = &quot;banana&quot;    </span><br><span class="line">fmt.Printf(&quot;%p %p&quot;, &amp;cat, &amp;str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果(内存地址，指针的值是带有<code>0x</code>十六进制前缀的一组数据)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xc042052088 0xc0420461b0</span><br></pre></td></tr></table></figure><blockquote><p>从指针获取指针指向的值</p></blockquote><p>当使用<code>&amp;</code>操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用<code>*</code>操作符，也就是<strong>指针取值</strong>，代码如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    // 准备一个字符串类型</span><br><span class="line">    var house = &quot;Malibu Point 10880, 90265&quot;</span><br><span class="line">    // 对字符串取地址, ptr类型为*string</span><br><span class="line">    ptr := &amp;house</span><br><span class="line">    // 打印ptr的类型</span><br><span class="line">    fmt.Printf(&quot;ptr type: %T\n&quot;, ptr)</span><br><span class="line">    // 打印ptr的指针地址</span><br><span class="line">    fmt.Printf(&quot;address: %p\n&quot;, ptr)</span><br><span class="line">    // 对指针进行取值操作</span><br><span class="line">    value := *ptr</span><br><span class="line">    // 取值后的类型</span><br><span class="line">    fmt.Printf(&quot;value type: %T\n&quot;, value)</span><br><span class="line">    // 指针取值后就是指向变量的值</span><br><span class="line">    fmt.Printf(&quot;value: %s\n&quot;, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr type: *string</span><br><span class="line">address: 0xc0420401b0</span><br><span class="line">value type: string</span><br><span class="line">value: Malibu Point 10880, 90265</span><br></pre></td></tr></table></figure><p>取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p><ul><li><p>对变量进行取地址操作使用<code>&amp;</code>操作符，可以获得这个变量的指针变量。</p></li><li><p>指针变量的值是指针地址。</p></li><li><p>对指针变量进行取值操作使用<code>*</code>操作符，可以获得指针变量指向的原变量的值。</p></li></ul><blockquote><h2 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h2></blockquote><p><a href="http://c.biancheng.net/view/21.html">原文地址</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>concat以及group_concat</title>
      <link href="/2021/03/22/concat%E4%BB%A5%E5%8F%8Agroup-concat/"/>
      <url>/2021/03/22/concat%E4%BB%A5%E5%8F%8Agroup-concat/</url>
      
        <content type="html"><![CDATA[<blockquote><p>concat()函数</p></blockquote><p>1.功能：将多个字符串连成一个字符串。</p><p>2.语法：concat(str1,str2,…)<br>返回结果为连接参数产生的字符串，如果有任何一个参数为NULL，则返回值为NULL。这边测试null，空白都没有效果，只有NULL有效。</p><p>3.举例:</p><table><thead><tr><th>id</th><th>姓</th><th>名</th></tr></thead><tbody><tr><td>1</td><td>林</td><td>晓明</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(id,first_name,last_name) <span class="keyword">as</span> info <span class="keyword">from</span> business_account_info <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果：1林晓明</p><p>添加分隔符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(id,&quot;.&quot;，first_name,&quot; &quot;,last_name) <span class="keyword">as</span> info <span class="keyword">from</span> business_account_info <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果：1.林 晓明</p><span id="more"></span><blockquote><p>concat_ws()函数</p></blockquote><p>concat函数的分隔符虽然多样，但需要一个一个填。如果是分隔符众多且都一致的情况下就显得很麻烦了。函数concat_ws完美解决。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat_ws(&quot;,&quot;,id,first_name,last_name) <span class="keyword">as</span> info <span class="keyword">from</span> business_account_info <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果: 1,林，晓明</p><p>当然，如果把分隔符指定为NULL，结果全部变成了NULL,对concat函数、concat_ws都适用。</p><blockquote><p>group_concat()函数</p></blockquote><p>这个就要复杂那么点。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,<span class="built_in">min</span>(score) <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure><p>这样我们可以看到小明、小东和茉茉的最低成绩:</p><table><thead><tr><th>name</th><th>min(score)</th></tr></thead><tbody><tr><td>小明</td><td>17</td></tr><tr><td>小东</td><td>11</td></tr><tr><td>茉茉</td><td>15</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,score <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure><p>这样我们可以看到，排序name，而score默认从大打小asc排序。这样也可以看到分数及最小分数。</p><table><thead><tr><th>name</th><th>score</th></tr></thead><tbody><tr><td>茉茉</td><td>15</td></tr><tr><td>茉茉</td><td>18</td></tr><tr><td>茉茉</td><td>20</td></tr><tr><td>小东</td><td>11</td></tr><tr><td>小东</td><td>14</td></tr><tr><td>小东</td><td>16</td></tr><tr><td>小明</td><td>17</td></tr><tr><td>小明</td><td>20</td></tr><tr><td>小明</td><td>21</td></tr></tbody></table><p>但不够直观，这时候group_concat()函数就登场了。</p><p>语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc&#x2F;desc ] [separator ‘分隔符’] )</p><p>说明：通过使用distinct可以排除重复值；如果希望对结果中的值进行排序，可以使用order by子句；separator是一个字符串值，缺省为一个逗号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,group_concat(score) <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure><p><a href="https://baijiahao.baidu.com/s?id=1595349117525189591&wfr=spider&for=pc">参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于学习的一些思考</title>
      <link href="/2021/03/15/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/2021/03/15/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>今天看了一篇文章，<a href="https://mp.weixin.qq.com/s/VSZbuj8HGs5IJNtNn4dvtg">关于如何学习技术的一点感悟</a> ,感到受益匪浅。</p><p>文章的内容主要分为两部分，对技术的学习,一是要战略上藐视技术，二是要战术上重视技术。</p><span id="more"></span><p>第一点很好理解，很多问题并不是这么难，但惧怕可以让它可怕百倍。对于这个问题，我的理解是，有些技术点确实比较复杂，甚至短期之内无法掌握，因此很多人就会惧怕，内心的抵制它。这大概也是这个时代的产物，功利性极强的表现。因此，只有战略上藐视技术，才能让你敢于学习技术，面对技术。但现实其实并没有改变，所以拆分化很重要，将大问题拆成一个个小问题。然后，再一个个问题解决，到后面就会水到渠成。</p><p>第二点其实是很多会忽略的，文中的举例很生动，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 老张把水壶放到火上，立等水开。（同步阻塞）</span><br><span class="line"></span><br><span class="line">2. 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）</span><br><span class="line"></span><br><span class="line">3. 老张把响水壶放到火上，立等水开。（异步阻塞）</span><br><span class="line"></span><br><span class="line">4. 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</span><br><span class="line"></span><br><span class="line">这就是他们的区别，没那么高深，一个例子就能解释透彻！</span><br><span class="line"></span><br><span class="line">在我看来呢，这个就属于典型的在战略上做到了藐视了技术，但在战术上却没有重视技术。</span><br></pre></td></tr></table></figure><p>看完这个例子，你是否觉得你已经完全掌握了同步和异步，阻塞和非阻塞的内容了。如果是，你就要小心了。</p><p>首先，这个例子丢失了理解这些概念的几乎全部的信息量：IO、线程挂起、立即返回未就绪状态码、回调函数 等。</p><p>其次，后面还加了一句话，说这个例子能把这个问题解释得很透彻。</p><p>然后，你掌握的就是你通过这个例子解读的信息，而解读是否存在偏差呢？更可怕的是如果这个例子也是别人解读其他人的例子，那么这种三手解读的偏差是否会扩大化呢？</p><p>最后，分享一个”个人的面试经历”，有的面试官会不让你举例，就要听原理(真实)。这种情况如果你不了解，这个问题可能连60分都拿不到。所以，类似的例子只是让我们更容易的去接触知识，不会害怕。但并非让我们放弃深入学习，藐视知识。请在例子的背后多打个问号，你真的懂了么？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>因选秀而引发的思考</title>
      <link href="/2021/03/10/%E5%9B%A0%E9%80%89%E7%A7%80%E8%80%8C%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2021/03/10/%E5%9B%A0%E9%80%89%E7%A7%80%E8%80%8C%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/03/10/%E5%9B%A0%E9%80%89%E7%A7%80%E8%80%8C%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/zs.jpeg"></p><p>虽然，算不上饭圈。但近两年的火爆男女团选秀也是跟着浪潮看了几期。</p><p>最近，刷微博热搜，看到连淮伟参加了”青你3”,初舞台获得C。普及一下，他在”青你1”获得第10名，然后前9名出道。换个说法，当年考985大学遗憾落榜但进入一所不错211大学的学长，在大学一年并没有荒废的情况下，心有不甘又回去准备高考了，结果第一场考试成绩只能上二本。</p><span id="more"></span><p>现实生活中会不会有这样的事情，掉到二本极难，但再次落榜不无可能。因为变数太多了，而想争夺的位置太前了。而人生也是如此，没有高考的限定，但人生的考试难道就可以无限期拖延么？不能的，大学毕业后你才是个出入社会的菜鸟。当你刚站稳脚跟，准备展望一切的时候…</p><p>30岁的大门已经在向你挥手了，然后是35岁，40岁一个接一个严峻的课题。抛开那些自带bgm的人外，好像确实没有沾沾自喜的时间，无论你拿到了哪些成就，只要还处于平凡的阶段。即使你想拖住一切，但周围的环境会不断影响你。同化独特性好像是人们很喜欢的一件事情，除非这个独特性开始让人仰望，这时候人们才会膜拜。</p><p>现在的社会太浮躁了，谁都想一蹴而就。24岁毕业的大学生，初入社会摸爬滚打个3~4年开始立足，这或许才是常态，而众人却渴望他在这时候完成登顶。还是先拿到主角的剧本吧。</p><p>其实，我们能做的不过是一步一步的努力，当机遇出现时不顾一切的抓住它。即使可能失手，但至少不顾一切的体验过了。万一，成功了呢？</p><p>努力不代表成功，它只是增加成功的概率。那么，你希望有多大的概率成功呢？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐一款画流程图工具</title>
      <link href="/2021/03/10/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/03/10/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>现在市面上的流程图画图工具很多，包括线上的也很多，这里不做比较，仅推荐自己感觉不错的一款<strong>免费</strong>工具(并非广告)。</p><p><a href="https://www.processon.com/">Processon</a></p><p>喜欢的小伙伴赶紧去试试吧~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后记录一下特殊密码:晴朗  md5  qq+x</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 工具推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2021/03/08/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2021/03/08/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p><em>二进制</em>（binary）在数学和数字电路中指以2为基数的记数系统，以2为基数代表系统是<em>二进位制</em>的。</p><p>简单的理解就是满二进一位，每一位只可能是0或1。</p><p>以1,2,3,4为例，1就是<strong>1</strong>; 而2在1的基础上加1，位满2进一位，所以前面新增一位是1，之前的栏位因为进位所以为0，二进制就是<strong>1 0</strong>;那么,3的情况就是在2的末位加上1，所为为 <strong>1 1</strong>; 最后,4在3的末位加1,末位满2需要往倒数第二位进位加1，末位则为0，倒数第二位因为末位进位也满2进位，所为为0，新增一位为1，就是 <strong>1 0 0</strong> 。</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><table><thead><tr><th><strong>运算符</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>\ &amp;#124;</td><td>位或</td></tr><tr><td>&amp;</td><td>位与</td></tr><tr><td>^</td><td>位异或</td></tr><tr><td>&lt;&lt;</td><td>位左移</td></tr><tr><td>&amp;#62;&amp;#62;</td><td>位右移</td></tr><tr><td>~</td><td>位取反</td></tr></tbody></table><p>上面就是常见的运算符。下面讲解具体的运算:</p><span id="more"></span><p><strong>| 位或 (1遇0保存1)</strong></p><p>举例：10 | 15</p><p>10 转二进制 1010</p><p>15 转二进制 1111</p><p>1010</p><p>1111</p><hr><p>1111</p><p>结果:15</p><p><strong>&amp; 位与(1遇0保存0)</strong></p><p>举例：10 &amp;15</p><p>10 转二进制 1010</p><p>15 转二进制 1111</p><p>1010</p><p>1111</p><hr><p>1010</p><p>结果:10</p><p><strong>位异或运算符 ( ^ ) ：对应的二进制位不相同时，结果为 1 ，否则为 0</strong></p><p>举例：10 ^15</p><p>10 转二进制 1010</p><p>15 转二进制 1111</p><p>1010</p><p>1111</p><hr><p>0101</p><p>结果:5</p><p><strong>位取反运算符 ( ~ ) ：将对应的二进制数逐位反转，即 1 取反后变 0 ， 0 取反后变 1</strong></p><p>~5</p><p>5 二进制 101，补满 32位<br>00000000000000000000000000000101</p><p>按位取反<br>11111111111111111111111111111010</p><p>由于32位开头第一个是1，所以这是一个负数，将 <em><strong>二进制转换成负数，需要先反码</strong></em><br>00000000000000000000000000000101</p><p><em><strong>之后，再+1</strong></em><br>00000000000000000000000000000110</p><p>转换成十进制为6，加上符号变成负数 -6;</p><p>所以，简单理解就是~5 等于5+1然后前头变负数。</p><p>同理~1 等于-2，</p><p>~-2 等于1(-2+1&#x3D;-1;负号变正号等于1)。</p><p><strong>位左移运算符 ( &lt;&lt; ) ：使指定的二进制位都左移指定的位数，左移指定位之后，左边高位的数值将被移出并丢弃，右边低位空出的位置用 0 补齐</strong></p><p>5&gt;&gt;2</p><p>0101</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0101   移位</p><p>0001        删位</p><p>结果:1</p><p><strong>位右移运算符 ( &gt;&gt; ) ：使指定的二进制位都右移指定的位数，右移指定位之后，右边低位的数值将被移出并丢弃，左边高位空出的职位用 0 补齐</strong></p><p>5&lt;&lt;2</p><p>0000 0101</p><p>0001 01          移位</p><p>0001 0100     补位</p><p>结果:20</p><h2 id="Mysql位运算简化一对多关系"><a href="#Mysql位运算简化一对多关系" class="headerlink" title="Mysql位运算简化一对多关系"></a><em><strong>Mysql位运算简化一对多关系</strong></em></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这个举个例子：这边涉及到位运算，首先我们先假设一个6位二进制，0代表关闭，1代表开启</span><br><span class="line">0 0 0 0 0 0   #这代表全关闭</span><br><span class="line">0 0 0 0 0 1   #只开启1    二的零次方 1</span><br><span class="line">0 0 0 0 1 0   #只开启2    二的一次方 2</span><br><span class="line">0 0 0 1 0 0   #只开启3    二的二次方 4</span><br><span class="line">0 0 1 0 0 0   #只开启4    二的三次方 8</span><br><span class="line">0 1 0 0 0 0   #只开启5    二的四次方 16 </span><br><span class="line">1 0 0 0 0 0   #只开启6    二的五次方 32</span><br></pre></td></tr></table></figure><p>所以，运用这个技巧，首先字段的值都要是以2的N次幂为基础，如下:</p><p>1，2，4，8，16，32，64，128，512，1024，2048，4096…</p><p>然后，把上面的每一个值当做一个属性。多个属性就进行累加，然后记录合。</p><p>为什么是2的N次幂呢？</p><p>因为这种情况下每个元素的二进制都有且仅有一个栏位为1，为1的栏位也都是不同的，赋予其独特性。而这种独特性有多奇妙，就要往下看了。</p><p>这个技巧适用于属性较少的一对多的场景，可以存储1个或者多个。</p><p>– 添加一个分类 用 “|”SELECT (4|2|1);  4+2+1&#x3D; 7 7代表这4，2，1三个属性。</p><p> 0001</p><p> 0010</p><p> 0100</p><hr><p> 0111</p><p>为什么可以直接相加呢？因为”|”是有1则为1，你会发现(当然是2的N次幂这种)，用“|”会增加一个为1的栏位，好巧这些值又都只是二进制只有一个栏位为1的值。</p><p>– 去掉一个分类，用“^”SELECT 7 ^ 1; 7-1&#x3D;6    6代表4,2这两个数据(不相同时，结果为 1 ，否则为 0)</p><p> 0111</p><p> 0001</p><hr><p>0110</p><p>– 当我们需要查询某个月份的景点时，例如查询3月份的景点，可使用以下语句：</p><p>SELECT * FROM <code>spots</code> WHERE <code>month</code> &amp; 4 &#x3D; 4;</p><p>– 当设置某个景点适合某个月份时，例如设置4325的景点适合2月份，可使用下面的语句：</p><p>UPDATE <code>spots</code> SET <code>month</code> &#x3D; <code>month</code> | 2 WHERE <code>id</code> &#x3D; 4325</p><p>– 当取消设置某个景点的月份时，可使用下面的语句：</p><p>UPDATE <code>spots</code> SET<code> month</code> &#x3D; <code>month</code> ^ 2 WHERE <code>id</code>&#x3D; 4325</p><p>– 查询同时适合多个月份的数据，例如需要查询设置了11，12，1月份的景点，将其三个月份对应的数值加起来，结果为6145，然后使用这个数值进行查询：</p><p>SELECT * FROM <code>spots</code> WHERE <code>month</code> &amp; 6145 &#x3D; 6145</p><p>– 查询只要适合，1,11,12月份其中一个月份的景点就行</p><p>SELECT * FROM <code>spots</code> WHERE (<code>month</code> &amp; 4096 &#x3D; 4096) or (<code>month</code> &amp; 2048 &#x3D; 2048) or (<code>month</code> &amp; 1 &#x3D; 1)</p><h2 id="php运用"><a href="#php运用" class="headerlink" title="php运用"></a>php运用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a &lt;&lt; $b    Shift left（左移） 将 $a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。</span><br><span class="line">$a &gt;&gt; $b   Shift right（右移） 将 $a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">那么反转，给你一个7如果解读，</span><br><span class="line">(7 &amp; 1)   &gt; 1      =&gt;   (7 &amp; （1 &lt;&lt; 0)) &gt; 1</span><br><span class="line">(7 &amp; 2)   &gt; 1      =&gt;   (7 &amp;  (1 &lt;&lt; 1))&gt; 1</span><br><span class="line">(7 &amp; 4)   &gt; 1      =&gt;   (7 &amp;  (1 &lt;&lt; 2))&gt; 1</span><br><span class="line">位运算会转成2进制，而&amp;的特性是都要为1才为1，这边的1，2，4都是只有一个位置为1，其他都为0。</span><br><span class="line">这样就可以通过是否为1判断。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
